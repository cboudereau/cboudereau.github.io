<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2018-05-14T18:10:43+02:00</updated><id>/</id><title type="html">Yet Another Geek Blog</title><subtitle>Yet Another Geek Blog : dev with fun(ction)</subtitle><entry><title type="html">Finding your baby name with fsharp</title><link href="/fsharp/data/hack/2018/05/11/finding-your-baby-name-with-fsharp.html" rel="alternate" type="text/html" title="Finding your baby name with fsharp" /><published>2018-05-11T08:23:10+02:00</published><updated>2018-05-11T08:23:10+02:00</updated><id>/fsharp/data/hack/2018/05/11/finding-your-baby-name-with-fsharp</id><content type="html" xml:base="/fsharp/data/hack/2018/05/11/finding-your-baby-name-with-fsharp.html">&lt;p&gt;First of all I am glad to have another child in my familly.&lt;/p&gt;

&lt;p&gt;He is my 2nd boy, so it was really hard for us to find another boy name.
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;I found this french data : https://www.insee.fr/fr/statistiques/fichier/2540004/nat2016_txt.zip but there is 14596 boys names; the choice is hard!&lt;/p&gt;

&lt;p&gt;How to find the pretty well name for my little boy ?&lt;/p&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;I was using this site : https://dataaddict.fr/prenoms/ and I saw one problem : Lack of classification.&lt;/p&gt;

&lt;p&gt;In spite of that point, the idea is good : to see how and when a name is used with stats.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;I would like to see names by their properties (long, short, composed, …).&lt;/li&gt;
  &lt;li&gt;And group them phonetically&lt;/li&gt;
  &lt;li&gt;See less than 100 names in a graph of usage per year&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So the aim of this hack was to provide a way to reduce the amount of name that we don’t wan’t due to their caracteristics.&lt;/p&gt;

&lt;h2 id=&quot;parsing-the-data&quot;&gt;Parsing the data&lt;/h2&gt;
&lt;p&gt;FSharp has a fast data analytics in its core so it is just one line to parse the csv.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#r &quot;packages/FSharp.Data/lib/net45/FSharp.Data.dll&quot;

open FSharp.Data

type FirstNameStats = CsvProvider&amp;lt; &quot;nat2016_txt/nat2016.txt&quot;, Separators = &quot;\t&quot;, HasHeaders=true &amp;gt;

let stats = FirstNameStats.Load(&quot;nat2016_txt/nat2016.txt&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now build a function that returns all name for a given gender by year.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module Int32 = 
    let tryInt x = 
        match System.Int32.TryParse(x) with
        | true, i -&amp;gt; Some i
        | _ -&amp;gt; None

type Gender = 
    | Masculine = 1
    | Feminine = 2

module Gender = 
    let value (s:Gender) = int s

type [&amp;lt;Struct&amp;gt;] Year = Year of int
type [&amp;lt;Struct&amp;gt;] FirstName = FirstName of string

let firstNames gender = 
    stats.Rows 
    |&amp;gt; Seq.choose (fun x -&amp;gt; 
        Int32.tryInt x.Annais 
        |&amp;gt; Option.bind (fun y -&amp;gt; if x.Sexe = (gender |&amp;gt; Gender.value) then Some (FirstName x.Preusuel, (Year y, x.Nombre)) else None) )

let boys = firstNames Gender.Masculine

boys |&amp;gt; Seq.take 10 |&amp;gt; Seq.toList

(* It outputs : 
[(FirstName &quot;A&quot;, (Year 1980, 3)); (FirstName &quot;A&quot;, (Year 1998, 3));
 (FirstName &quot;AADAM&quot;, (Year 2009, 4)); (FirstName &quot;AADAM&quot;, (Year 2014, 3));
 (FirstName &quot;AADAM&quot;, (Year 2016, 4)); (FirstName &quot;AADEL&quot;, (Year 1976, 5));
 (FirstName &quot;AADEL&quot;, (Year 1978, 3)); (FirstName &quot;AADEL&quot;, (Year 1980, 3));
 (FirstName &quot;AADEL&quot;, (Year 1981, 5)); (FirstName &quot;AADEL&quot;, (Year 1982, 4))]
*)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now that we have names in memory, how can I classify information and search in it ?&lt;/p&gt;

&lt;h2 id=&quot;classify-classify-classify&quot;&gt;Classify, classify, classify&lt;/h2&gt;
&lt;p&gt;After analysing the data, I was finding my name (Clément) when I see that there was different spelling (accent and other difference).
To reduce the amount of duplicate phonetic match, I would like to group name phonetically.&lt;/p&gt;

&lt;p&gt;The main problem with phonetic algorithm was the lowest tolerance with cross language spelling variation.&lt;/p&gt;

&lt;p&gt;Here is some cases where I did not find the right math :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;“Yolaine” : “Yolène”, “Yolene”&lt;/li&gt;
  &lt;li&gt;“Clément” : “Clement”, “Klement”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I try with different french algorithms like Soundex and Phonex and the best one was Phonex (Good balance between redundancy and spelling variation).&lt;/p&gt;

&lt;p&gt;I patched the Phonex algorithm to match the 2 cases “Yolaine” and “Clement”.&lt;/p&gt;

&lt;p&gt;You can check the differences &lt;a href=&quot;https://github.com/cboudereau/firstname/commit/a2fee2492820fe59d2df928cd82473f27086fe96#diff-03d56f95fd97ac5769359687562f51e7&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;You could see the result of my attempts to use soundex2 instead.&lt;/p&gt;

&lt;p&gt;Here is the patched translation in fsharp of &lt;a href=&quot;https://github.com/Noethys/Teamworks/blob/master/source/Phonex.py&quot;&gt;this python implementation&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;phonetic-hash&quot;&gt;Phonetic Hash&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module Phonex = 
    let toLower x = (x:string).ToLower ()
    let accentLess x = System.Text.Encoding.GetEncoding(&quot;ISO-8859-8&quot;).GetBytes(x:string) |&amp;gt; System.Text.Encoding.UTF8.GetString
    let replace target replacement source = (source:string).Replace((target:string), replacement)
    let rI = replace &quot;y&quot; &quot;i&quot;
    let rF = replace &quot;ph&quot; &quot;f&quot; 
    let replaceAny targets replacement source = targets |&amp;gt; List.fold (fun s t -&amp;gt; replace t replacement s) source
    let rCh = replaceAny [&quot;sh&quot;; &quot;ch&quot;; &quot;sch&quot;] &quot;5&quot;
    let remove target source = replace target &quot;&quot; source
    let rmH = remove &quot;h&quot;
    let rmapping tr source = tr |&amp;gt; List.fold (fun s (t,r) -&amp;gt; replace t r s) source
    let rGan = rmapping [ &quot;gan&quot;, &quot;kan&quot;
                          &quot;gam&quot;, &quot;kam&quot;
                          &quot;gain&quot;, &quot;kain&quot;
                          &quot;gaim&quot;, &quot;kaim&quot; ]
    let between before after replacement source target = 
        let rec between offset source = 
            if offset &amp;lt; (source:string).Length then 
                let lt = (target:string).Length
                let tail = source.Substring(offset)
                let idx = tail.IndexOf(target)
                if idx &amp;lt;&amp;gt; -1 &amp;amp;&amp;amp; (before (tail.Substring(0, idx)) &amp;amp;&amp;amp; after(tail.Substring(idx + lt))) then
                    sprintf &quot;%s%s%s&quot; (source.Substring(0, offset + idx)) replacement (tail.Substring(idx + lt, tail.Length - idx - lt))
                    |&amp;gt; between (idx + replacement.Length)
                else source
            else source
        between 0 source
    let all = fun _ -&amp;gt; true
    let suffix f replacement source target = between all f replacement source target
    let suffixL f replacement targets source = targets |&amp;gt; List.fold (suffix f replacement) source
    let [&amp;lt;Literal&amp;gt;] Vowel = &quot;aeiou&quot;
    let isVowel x = Vowel |&amp;gt; Seq.exists ((=) x)
    let tryIsVowel = Option.map isVowel &amp;gt;&amp;gt; Option.defaultValue false 
    let tryIsNotVowel = tryIsVowel &amp;gt;&amp;gt; not
    let rAin  = [&quot;ain&quot;; &quot;ein&quot;; &quot;ain&quot;; &quot;eim&quot;; &quot;aim&quot;] |&amp;gt; suffixL (Seq.tryHead &amp;gt;&amp;gt; tryIsVowel) &quot;en&quot;
    let rO = replace &quot;eau&quot; &quot;o&quot;
    let rOua = replace &quot;oua&quot; &quot;2&quot;
    let rEin = replaceAny [&quot;ein&quot;;&quot;ain&quot;;&quot;eim&quot;;&quot;aim&quot;] &quot;4&quot;
    let rAi = replaceAny [&quot;ai&quot;;&quot;ei&quot;] &quot;e&quot;
    let rEr = replace &quot;er&quot; &quot;yr&quot;
    let rEss = replace &quot;ess&quot; &quot;yss&quot;
    let rEt = replace &quot;et&quot; &quot;yt&quot;
    let rAn = [&quot;an&quot;;&quot;am&quot;;&quot;en&quot;;&quot;em&quot;] |&amp;gt; suffixL (Seq.tryHead &amp;gt;&amp;gt; tryIsNotVowel) &quot;1&quot;
    let rIn source = suffix (Seq.tryHead &amp;gt;&amp;gt; tryIsNotVowel) &quot;4&quot; source &quot;in&quot;
    let rOn = replace &quot;on&quot; &quot;1&quot;
    let rZ source = 
        let isCandidate c = ['1' .. '4'] |&amp;gt; List.append (Vowel |&amp;gt; Seq.toList) |&amp;gt; List.exists ((=) c)
        let tryIsCandidate = Option.map isCandidate &amp;gt;&amp;gt; Option.defaultValue false
        between (Seq.tryLast &amp;gt;&amp;gt; tryIsCandidate) (Seq.tryHead &amp;gt;&amp;gt; tryIsCandidate) &quot;z&quot; source &quot;s&quot;
    let rE = replaceAny [&quot;oe&quot;;&quot;eu&quot;] &quot;e&quot;
    let rAu = replace &quot;au&quot; &quot;o&quot;
    let rOi = replaceAny [&quot;oi&quot;; &quot;oy&quot;] &quot;2&quot;
    let rOu = replace &quot;ou&quot; &quot;3&quot;
    let rS = replaceAny [&quot;ss&quot;;&quot;sc&quot;] &quot;s&quot;
    let rC source = 
        let isCandidate c = &quot;ei&quot; |&amp;gt; Seq.exists ((=) c)
        let tryIsCandidate = Seq.tryHead &amp;gt;&amp;gt; Option.map isCandidate &amp;gt;&amp;gt; Option.defaultValue false
        suffix tryIsCandidate &quot;s&quot; source &quot;c&quot;
    let rK = replaceAny [&quot;c&quot;;&quot;q&quot;;&quot;qu&quot;;&quot;gu&quot;] &quot;k&quot;
    let rGa = replace &quot;ga&quot; &quot;ka&quot;
    let rGo = replace &quot;go&quot; &quot;ko&quot;
    let rGy = replace &quot;gy&quot; &quot;ky&quot;
    let trim letters = 
        Seq.distinct &amp;gt;&amp;gt; Seq.toArray
        &amp;gt;&amp;gt; fun y -&amp;gt; 
            let n = Array.length y - 1
            let c = y.[n] 
            if letters |&amp;gt; List.exists ((=) c) then Array.take n y 
            else y
        &amp;gt;&amp;gt; System.String

    let rLast =
        rmapping [ &quot;a&quot;,&quot;o&quot;
                   &quot;d&quot;,&quot;t&quot;
                   &quot;p&quot;,&quot;t&quot;
                   &quot;j&quot;,&quot;g&quot;
                   &quot;b&quot;,&quot;f&quot;
                   &quot;v&quot;,&quot;f&quot;
                   &quot;m&quot;,&quot;n&quot; ]

    let hash = 
        toLower &amp;gt;&amp;gt; accentLess 
        &amp;gt;&amp;gt; rI &amp;gt;&amp;gt; rF &amp;gt;&amp;gt; rCh &amp;gt;&amp;gt; rmH 
        &amp;gt;&amp;gt; rGan &amp;gt;&amp;gt; rAin &amp;gt;&amp;gt; rO &amp;gt;&amp;gt; rOua
        &amp;gt;&amp;gt; rEin &amp;gt;&amp;gt; rAi 
        &amp;gt;&amp;gt; rEr &amp;gt;&amp;gt; rEss &amp;gt;&amp;gt; rEt
        &amp;gt;&amp;gt; rAn &amp;gt;&amp;gt; rIn &amp;gt;&amp;gt; rOn
        &amp;gt;&amp;gt; rZ &amp;gt;&amp;gt; rE &amp;gt;&amp;gt; rAu &amp;gt;&amp;gt; rOi &amp;gt;&amp;gt; rOu
        &amp;gt;&amp;gt; rS &amp;gt;&amp;gt; rC &amp;gt;&amp;gt; rK &amp;gt;&amp;gt; rGa &amp;gt;&amp;gt; rGo &amp;gt;&amp;gt; rGy
        &amp;gt;&amp;gt; rLast
        &amp;gt;&amp;gt; trim ['x';'t']

Phonex.hash &quot;klement&quot; //kl1
Phonex.hash &quot;clément&quot; //kl1
Phonex.hash &quot;clement&quot; //kl1

Phonex.hash &quot;clemens&quot; //kl1s

Phonex.hash &quot;yolaine&quot; //iolen
Phonex.hash &quot;yolène&quot;  //iolen
Phonex.hash &quot;yoléne&quot;  //iolen
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is not the best implementation (due to string allocations) but it is ok for our case. 
I tried to use FParsec for this case but the performance was not really impressive (may be I was wrong.).
Here is my attempt if you want to give me a better implementation : https://github.com/cboudereau/firstname/blob/master/phonex.fsx&lt;/p&gt;

&lt;p&gt;The main point : the function composition of the Phonex hash function&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Pipeline pattern&lt;/li&gt;
  &lt;li&gt;Easy to fix&lt;/li&gt;
  &lt;li&gt;Easy to test (unit tests or integration tests)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Sounds good :)&lt;/p&gt;

&lt;h2 id=&quot;a-quick-test&quot;&gt;A quick test&lt;/h2&gt;

&lt;p&gt;Now that we have the algorithm to hash phonetically names, we can write a function that reduces the names count!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module Snd = 
    let map f (x,y) = x, f y

type [&amp;lt;Struct&amp;gt;] Phonetic = Phonetic of string

let phonetic f = 
    Seq.map (fun ((FirstName n), (y, c)) -&amp;gt; f n |&amp;gt; Phonetic, (y,(FirstName n,c)))
    &amp;gt;&amp;gt; Seq.groupBy fst
    &amp;gt;&amp;gt; Seq.map ( 
        Snd.map (
            Seq.map snd 
            &amp;gt;&amp;gt; Seq.groupBy fst 
            &amp;gt;&amp;gt; Seq.map (Snd.map (Seq.map snd)) 
            &amp;gt;&amp;gt; Seq.sortBy fst))

let pBoys = boys |&amp;gt; phonetic Phonex.hash

pBoys |&amp;gt; Seq.map (Snd.map (Seq.collect snd &amp;gt;&amp;gt; Seq.map fst &amp;gt;&amp;gt; Seq.distinct &amp;gt;&amp;gt; Seq.toList)) |&amp;gt; Map.ofSeq
|&amp;gt; Map.tryFind (Phonex.hash &quot;Clément&quot; |&amp;gt; Phonetic)

(*
val it : FirstName list option =
  Some
    [FirstName &quot;CLÉMENT&quot;; FirstName &quot;CLEMENT&quot;; FirstName &quot;KLEMENT&quot;;
     FirstName &quot;KLÉMENT&quot;]
*)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hey not bad !&lt;/p&gt;

&lt;p&gt;Now we have only 7413 names to check.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A name has around 2 spellings.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;7413 names is still high to check names and with my wife we know what kind of name we don’t want (too long, too short, …)&lt;/p&gt;

&lt;h2 id=&quot;phonetic-categorization&quot;&gt;Phonetic categorization&lt;/h2&gt;
&lt;p&gt;For the next part, we will use this block of code.
We can for example control the phonetic length of the name.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module Phonetic = 
    let value (Phonetic p) = p
    let short = value &amp;gt;&amp;gt; fun p -&amp;gt; p.Length &amp;lt; 7
    let little = value &amp;gt;&amp;gt; fun p -&amp;gt; p.Length &amp;lt; 3
    let onlyComposed = value &amp;gt;&amp;gt; fun p -&amp;gt; p.Contains(&quot;-&quot;)
    let notComposed = onlyComposed &amp;gt;&amp;gt; not
    let blacklist l = 
        let bl = l |&amp;gt; Seq.map value |&amp;gt; Seq.toList
        value
        &amp;gt;&amp;gt; fun p -&amp;gt; bl |&amp;gt; List.exists ((=) p) |&amp;gt; not
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;composed-or-not-composed-&quot;&gt;Composed or not composed ?&lt;/h3&gt;
&lt;p&gt;Depending of your choice, composed names can right down the problem quickly.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let onlyComposed = pBoys |&amp;gt; Seq.filter (fst &amp;gt;&amp;gt; Phonetic.onlyComposed) 
onlyComposed |&amp;gt; Seq.length //975
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let notComposed = pBoys |&amp;gt; Seq.filter (fst &amp;gt;&amp;gt; Phonetic.notComposed) 
notComposed |&amp;gt; Seq.length //6438
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We choosed the not composed version :)&lt;/p&gt;

&lt;h3 id=&quot;short-or-long-&quot;&gt;Short or long ?&lt;/h3&gt;
&lt;p&gt;In france there is a one letter name “A”.
We choose a not too short and not too long name for our baby (between 3 and 7 sounds) :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let notComposedAndShort = notComposed |&amp;gt; Seq.filter (fst &amp;gt;&amp;gt; Phonetic.short)
notComposedAndShort |&amp;gt; Seq.length //5953

let notComposedAndTooShort = notComposedAndShort |&amp;gt; Seq.filter (fst &amp;gt;&amp;gt; Phonetic.little &amp;gt;&amp;gt; not)
notComposedAndTooShort |&amp;gt; Seq.length //5827
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As usual we choose the less restrictive… :)&lt;/p&gt;

&lt;h3 id=&quot;mixed-&quot;&gt;Mixed ?&lt;/h3&gt;
&lt;p&gt;We want a masculine only name (ie: France could be a masculine or feminine name)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let pGirl = firstNames Gender.Feminine |&amp;gt; phonetic Phonex.hash
let onlyBoys = notComposedAndTooShort |&amp;gt; Seq.filter (fst &amp;gt;&amp;gt; (Phonetic.blacklist (pGirl |&amp;gt; Seq.map fst |&amp;gt; Seq.toList)))
onlyBoys |&amp;gt; Seq.length //3752
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;classic-or-not-&quot;&gt;Classic or not ?&lt;/h3&gt;
&lt;p&gt;According to the data, a classic name is used 5000 times from the beginning of the stats (20th century).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let classic = onlyBoys |&amp;gt; Seq.filter (snd &amp;gt;&amp;gt; Seq.collect snd &amp;gt;&amp;gt; Seq.sumBy snd &amp;gt;&amp;gt; (&amp;lt;) 5000)
classic |&amp;gt; Seq.length //95
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we got it : 95 names!&lt;/p&gt;

&lt;h2 id=&quot;graph-it-&quot;&gt;Graph it !&lt;/h2&gt;
&lt;p&gt;For this part I use XPlot.GoogleCharts that is pretty awesome for our needs.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#I &quot;packages/Google.DataTable.Net.Wrapper/lib/&quot;
#I &quot;packages/XPlot.GoogleCharts/lib/net45/&quot;
#r &quot;XPlot.GoogleCharts.dll&quot;
open XPlot.GoogleCharts

let result = classic

let graph average (data:(string * seq&amp;lt;System.DateTime*float&amp;gt;) list) =     
    let labels = data |&amp;gt; List.map fst
    let points = data |&amp;gt; List.map snd
    let options =
        Options(
            title = &quot;Number of firstname by year and average&quot;,
            vAxis = Axis(title = &quot;Count&quot;),
            hAxis = Axis(title = &quot;Year&quot;),
            series =
                [|
                    yield Series(``type`` = &quot;lines&quot;)
                    yield! labels |&amp;gt; Seq.map (fun _ -&amp;gt; Series(``type`` = &quot;bars&quot;))
                |]
        )
 
    (average :: points)
    |&amp;gt; Chart.Combo
    |&amp;gt; Chart.WithOptions options
    |&amp;gt; Chart.WithLabels (&quot;Average&quot; :: labels)
    |&amp;gt; Chart.Show

let average = 
    Seq.collect (snd &amp;gt;&amp;gt; Seq.map (Snd.map (Seq.sumBy snd)))
    &amp;gt;&amp;gt; Seq.groupBy fst
    &amp;gt;&amp;gt; Seq.map (fun (Year y,c) -&amp;gt; System.DateTime(y,1,1), c |&amp;gt; Seq.averageBy (snd &amp;gt;&amp;gt; float))
    &amp;gt;&amp;gt; Seq.sortBy fst
    &amp;gt;&amp;gt; Seq.toList

let datas = 
    Seq.map (fun (_, s) -&amp;gt;
        let mostUsedName = s |&amp;gt; Seq.collect snd |&amp;gt; Seq.sortByDescending snd |&amp;gt; Seq.map fst |&amp;gt; Seq.head
        mostUsedName, s |&amp;gt; Seq.map (Snd.map (Seq.sumBy snd)))
    &amp;gt;&amp;gt; Seq.map (fun (FirstName n, s) -&amp;gt; n, s |&amp;gt; Seq.map (fun (Year y, c) -&amp;gt; System.DateTime(y,1,1), float c) |&amp;gt; Seq.sortBy fst)

let av = average result

datas result |&amp;gt; Seq.toList |&amp;gt; graph av
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;final-result&quot;&gt;Final Result&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/images/namestats.png&quot; alt=&quot;Final result&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You can checkout the code &lt;a href=&quot;https://github.com/cboudereau/firstname/blob/master/blog.fsx&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My little boy is named Baptiste&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;I guess we could analyse the keyword of baby name descriptions from Internet and then categorize them into a graph and navigate inside. 
It would be nice! If you done it, do not hesitate to contact me!&lt;/p&gt;</content><author><name></name></author><summary type="html">First of all I am glad to have another child in my familly. He is my 2nd boy, so it was really hard for us to find another boy name.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/images/baptiste.png" /></entry><entry><title type="html">[Books] Sketchup for dummies review</title><link href="/3d/books/learning/2017/12/24/sketchup-for-dummies-review.html" rel="alternate" type="text/html" title="[Books] Sketchup for dummies review" /><published>2017-12-24T12:29:00+01:00</published><updated>2017-12-24T12:29:00+01:00</updated><id>/3d/books/learning/2017/12/24/sketchup-for-dummies-review</id><content type="html" xml:base="/3d/books/learning/2017/12/24/sketchup-for-dummies-review.html">&lt;p&gt;Sketchup is easy to use but to mastering it and creating wonderfull things you need some help.
Sketchup for dummies! For dummies ? Don’t be shy and try the experience thanks to &lt;a href=&quot;https://twitter.com/rebeccahuehls/&quot;&gt;Rebecca Huehls&lt;/a&gt;
&lt;!--more--&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/sketchup-for-dummies.jpg&quot; alt=&quot;Sketchup for dummies&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;the-friend-of-your-dreams&quot;&gt;The friend of your dreams!&lt;/h2&gt;

&lt;p&gt;I often use Sketchup for buildings purpose. I plan my works and build scaled plan to check the requirements but if you are a geek like me, You want a realistic model like this :&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/Scene 1_night.jpg&quot; alt=&quot;Model of my futur room&quot; /&gt;&lt;/p&gt;

&lt;p&gt;But before you make your dreams or your plan, be prepared!&lt;/p&gt;

&lt;h2 id=&quot;when-and-why-read-this-books&quot;&gt;When and why read this books&lt;/h2&gt;

&lt;p&gt;Firstly, Sketchup is easy to use thanks youtube channels but when you want to build more complex things, you have to find a solution and it is too late. Too late to create component and understand how to compose and build parts together and having a maintanable and extensible model.&lt;/p&gt;

&lt;p&gt;After watching a lots of videos I have found a great and easy to read book. Sketchup for dummies. The book is not really for dummies! It is well organized and you could read less than 50 pages to master components and buildings.&lt;/p&gt;

&lt;p&gt;If you are in a hurry you could start reading the chapter 4 “Building Buildings” and 5 “Falling in Love with Components”.&lt;/p&gt;

&lt;p&gt;You should consider reading this book when you fell a little bit lost with videos.&lt;/p&gt;

&lt;h2 id=&quot;chapters&quot;&gt;Chapters&lt;/h2&gt;

&lt;p&gt;Table of contents is well organised and title are OK if you known what thing you would like to build. But first chapter 4 and 5 are the first chapters to read and practice before going deeper with your models.&lt;/p&gt;

&lt;p&gt;When I started using sketchup 7 years ago, I have built models quickly but it was really difficult to keep the same speed due to interaction with existing. That is why this book is for!&lt;/p&gt;

&lt;p&gt;Chapters are separated between architectures categories, 3D printing, and lived objects like cover composed with complex forms.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;If you are interested in learning sketchup quickly or in depth, this book offers a bigger experience than videos. Tools are well described and there is always an example. There is also “geek part” to go deeper than “normal” case and that is why the book is easy to read by pass with last pass “geek” mode.&lt;/p&gt;

&lt;p&gt;You could buy this book at &lt;a href=&quot;https://www.amazon.com/SketchUp-Dummies-Computers-Aidan-Chopra-ebook/dp/B06XGNPR8Z&quot;&gt;amazon&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The author is really sympatic and you can enhance your experience by using twitter at : &lt;a href=&quot;https://twitter.com/rebeccahuehls/&quot;&gt;@rebeccahuehls&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Sketchup is easy to use but to mastering it and creating wonderfull things you need some help. Sketchup for dummies! For dummies ? Don’t be shy and try the experience thanks to Rebecca Huehls</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/images/sketchup-for-dummies_thumbs.jpg" /></entry><entry><title type="html">How to reduce false negative in software testing!</title><link href="/fsharp/qa/scripting/2017/11/23/how-to-reduce-false-negative-in-software-testing.html" rel="alternate" type="text/html" title="How to reduce false negative in software testing!" /><published>2017-11-23T12:04:00+01:00</published><updated>2017-11-23T12:04:00+01:00</updated><id>/fsharp/qa/scripting/2017/11/23/how-to-reduce-false-negative-in-software-testing</id><content type="html" xml:base="/fsharp/qa/scripting/2017/11/23/how-to-reduce-false-negative-in-software-testing.html">&lt;p&gt;As a QA, you have to write/maintain some code in order to automate your activities.
This activity is the same dev activity but… How do you test your code ?
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;use-the-right-tools&quot;&gt;Use the right tools&lt;/h2&gt;

&lt;p&gt;Even if you use a tool, you have to integrate it to the existing QA environment. So you have to write code.
Some QA teams builds a real app, libraries or exe.&lt;/p&gt;

&lt;p&gt;If you build a library, consider this activity like a dev and make unit test/build/ci.&lt;/p&gt;

&lt;p&gt;If you make an exe you are into the wrong path! If you do that you also need a QA!&lt;/p&gt;

&lt;h2 id=&quot;qa-of-qa-whats-wrong-&quot;&gt;QA of QA! What’s wrong ??&lt;/h2&gt;
&lt;p&gt;The QA of QA comes when you have a codebase that evolves and produces false negative.
For example, your campaign is failing because you have introduced a bug into you setup script or whatever. 
This business part is not tested and should not be tested!&lt;/p&gt;

&lt;p&gt;If the code is reusable and technical, it’s ok to build a library (ie:scrapping lib, xml utils, …)&lt;/p&gt;

&lt;p&gt;What about plumbing part like setup/teardown functions ?
Generally this sort of code is hard to maintain and you have to run the entire test to get the problem.
Running constantly the entire test to fix the setup/teardown part is wasting time! 
This kind of tests could ran into 10 or 30s (or even higher) and because they are too long you loose the focus of the last problem. 
So the number of iterations is higher than fixing code with a little test.
Associated unit tests are hard to produce because it is side effect functions like executing sql query or enabling queue logging.
If you have this problem, try to use alpha test.
If the check part is possible consider using post assert in order to check the state before running test.&lt;/p&gt;

&lt;p&gt;An alpha test is a little test built by the developper in order to check a very little part (not the entier QA test but one step of the setup/teardown part).
This test must be easy to write and easy to check.&lt;/p&gt;

&lt;h2 id=&quot;how-do-you-run-alpha-test-from-existing-code-base-&quot;&gt;How do you run alpha test from existing code base ?&lt;/h2&gt;
&lt;p&gt;First of all, you have to use a language having scripting and REPL properties like fsharp.
In my experience, our QA team uses a csharp solution with specflow but there were no tests on the setup and teardown part.
Sometimes they have false negative due to regression on the setup/teardown part. After understanding the problem, the queue logging part was not ok in that case.
The problem was too complex to fix into the existing codebase, so we used the divide and conquer principle!
First we extracted the code that activate the logging part into a fsharp script.
Side effects are often hard to check so we used alpha testing by calling the fsharp func making the side effects and checked that the log was activated.
Thanks to fsharp and its REPL + scripting properties executing a part of the setup/teardown is easier than the previous one plus the flow to produce the code force the QA dev to build very little function that do one thing at a time and packaging them into modules.&lt;/p&gt;

&lt;p&gt;In the end, a new fsharp assembly has been created and an associated script has been added to check the setup teardown using function composition even if it side effect and no familiar with functional programming paradigm.
The .fs files could be alpha tested separately into a script and exposed to csharp.&lt;/p&gt;

&lt;p&gt;Here is for example hard code to test :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let hello = printfn &quot;hello %s&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;You can say that testing the StandardOuput is ok, but you have to add a lots of plumbing into your code to have the benefit.
For this kind of function calling them directly and run it into an interactive is very easy because only one test is ok to check the effect.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;hello &quot;QA&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It is realy easy to press Alt+Enter and check that the function display hello QA!&lt;/p&gt;

&lt;p&gt;Here is what the interactive displays :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val hello : (string -&amp;gt; unit)

&amp;gt;
&amp;gt;
hello QA
val it : unit = ()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;As a QA, if you have constantly false negative, try to use alpha test before pushing the code.&lt;/li&gt;
  &lt;li&gt;Alpha test, reduces the time to fix the problem by executing the impacted code part and checking step by step that everything is ok (REPL style).&lt;/li&gt;
  &lt;li&gt;Alpha test driven dev is ok for not valuable automated test (the check is too complex or the cost is too high).&lt;/li&gt;
  &lt;li&gt;If you are a .Net QA, try to use fsharp in place of existing codebase (ie : the setup/teardown part).&lt;/li&gt;
  &lt;li&gt;The flow to produce scripts is more efficient by always checking that the code is working.&lt;/li&gt;
  &lt;li&gt;It is a good way to learn fsharp and function programming step by step.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">As a QA, you have to write/maintain some code in order to automate your activities. This activity is the same dev activity but… How do you test your code ?</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/images/inception.jpg" /></entry><entry><title type="html">Why we use fsharp data in prod</title><link href="/fsharp/data/prod/2017/08/18/why-we-use-fsharp-data-in-prod.html" rel="alternate" type="text/html" title="Why we use fsharp data in prod" /><published>2017-08-18T13:04:00+02:00</published><updated>2017-08-18T13:04:00+02:00</updated><id>/fsharp/data/prod/2017/08/18/why-we-use-fsharp-data-in-prod</id><content type="html" xml:base="/fsharp/data/prod/2017/08/18/why-we-use-fsharp-data-in-prod.html">&lt;p&gt;I am currently working at a company that deal with hundreds of connectivities (apps protocol and domain adapters + big data).&lt;/p&gt;

&lt;p&gt;Since 2014 we have used fsharp data progressively in production (I use fsharp in prod since 2012).&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;Today we have more than 10% and 1 of the top 3 (top business, high performance) in prod plus a custom big data solution in full fsharp (the company guarantee in case of sales/stockout risk for exchanged data thanks to zmq + 7z + Azure)&lt;/p&gt;

&lt;p&gt;We use fsharp data into different stages of a project : estimation, proof of concept, dev.&lt;/p&gt;

&lt;p&gt;After 3 years of production with fsharp, I would like to serialize my experience.&lt;/p&gt;

&lt;h2 id=&quot;our-context&quot;&gt;Our context&lt;/h2&gt;

&lt;p&gt;A connectivity is an adapter to exchange data with a partner.
This partner use often a “standard”. This standard &lt;a href=&quot;http://opentravel.org/#sthash.4w8LbhfH.dpbs&quot;&gt;OTA&lt;/a&gt; try to unify the communication between two partner. The bad news is : everything in OTA is optional.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;70% of our partner try to use OTA standard and others use their own protocol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What’s the problem ?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The protocol is verbose (really hard to see with the key data in an editor, due to semantic issue, interval scope, …)
Every partner has his own set of required and optional data.
Values are defined on an interval (another post could be dedicated to this part) and each partner has his own interval valued scope
Some partner does not use OTA anymore or they don’t know that OTA exists (due to historical reason, …)
Even if the partner has a poor interface, we have to integrate it has quick as possible&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;code-analysis-on-our-existing-apps&quot;&gt;Code analysis on our existing apps&lt;/h2&gt;
&lt;p&gt;When I was arrived in this company, I had ran &lt;a href=&quot;http://www.ndepend.com/&quot;&gt;NDepend&lt;/a&gt; and &lt;a href=&quot;https://www.sonarqube.org/&quot;&gt;Sonar&lt;/a&gt; to see :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;how modules are dependent (visualize and navigate to the dependency graph)&lt;/li&gt;
  &lt;li&gt;how many lines of codes depend on a module (+ the use of Resharper)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each connector has approximatively 35% of codes that use &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Xml.Linq&lt;/code&gt; and 50% of tests are dedicated to serialization/deserialization part (test are focussed on serialization + domain adaptation without separation).&lt;/p&gt;

&lt;h2 id=&quot;maintenability&quot;&gt;Maintenability&lt;/h2&gt;
&lt;p&gt;When we have to fix an existing app, we have to add a test, run the test and see where there was a problem.
It is really boring and the partner will often break their compatibility.&lt;/p&gt;

&lt;p&gt;When we build a new connector with xml linq, we have in the end a lot of method like this :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static Stuff BuildStuff(XDocument responseXml, XElement name)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Passing &lt;code class=&quot;highlighter-rouge&quot;&gt;XElement&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;XDocument&lt;/code&gt;, any xml linq parameter does not supply the context : the what. We have constantly to dev with the sample to the right side because it is totally dynamic.&lt;/p&gt;

&lt;p&gt;When I analyse this kind of code it is really hard to analyse the code without the sample and the big picture.&lt;/p&gt;

&lt;p&gt;Here is a xml data sample (this is not a domain dependent sample) :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;node&amp;gt;

	&amp;lt;item&amp;gt;
		&amp;lt;value&amp;gt;10&amp;lt;/value&amp;gt;
	&amp;lt;/item&amp;gt;
	&amp;lt;value&amp;gt;100&amp;lt;/value&amp;gt;

&amp;lt;/node&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;the associated code that get all values:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Program
{
	private static IEnumerable&amp;lt;decimal&amp;gt; Values(XElement x)
	{
		return x.Descendants(&quot;value&quot;).Select(y =&amp;gt; Decimal.Parse(y.Value));
	}
	static void Main(string[] args)
	{
		var xml = XDocument.Parse(@&quot;&amp;lt;node&amp;gt;&amp;lt;item&amp;gt;&amp;lt;value&amp;gt;10&amp;lt;/value&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;value&amp;gt;100&amp;lt;/value&amp;gt;&amp;lt;/node&amp;gt;&quot;);

		var v1 = Values(xml.Root);
		var v2 = Values(xml.Descendants(&quot;item&quot;).First());

		Console.WriteLine(&quot;from root&quot;);
		v1.ToList().ForEach(x =&amp;gt; Console.WriteLine(&quot;value : {0}&quot;, x));

		Console.WriteLine(&quot;from item&quot;);
		v2.ToList().ForEach(x =&amp;gt; Console.WriteLine(&quot;value : {0}&quot;, x));

		Console.ReadLine();
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When the data is bigger, the number of this kind of method is also bigger you have to analyse the usage of the method to understand the context.&lt;/p&gt;

&lt;p&gt;In the previous sample, the function does not return the same value depending of the context (because it force to use the metadata, the XElement instead of using the real data).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note : I try to use xsd.exe to generate the same C# code but there is some strange partner xml that not works correctly with xsd. When it works, the generated code is really hard to update.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;in 99% our partner does not supply an xsd. This solution works only for xml and not for json&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here is a version with the XmlProvider of &lt;a href=&quot;http://fsharp.github.io/FSharp.Data/&quot;&gt;Fsharp.Data&lt;/a&gt; :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#r @&quot;..\packages\FSharp.Data\lib\net40\FSharp.Data.dll&quot;
#r &quot;System.Xml.Linq&quot;

open FSharp.Data

let [&amp;lt;Literal&amp;gt;] nodeSample = &quot;&quot;&quot;&amp;lt;node&amp;gt;

	&amp;lt;item&amp;gt;
		&amp;lt;value&amp;gt;10&amp;lt;/value&amp;gt;
	&amp;lt;/item&amp;gt;
	&amp;lt;value&amp;gt;100&amp;lt;/value&amp;gt;

&amp;lt;/node&amp;gt;&quot;&quot;&quot;

type Node = XmlProvider&amp;lt; nodeSample &amp;gt;

let node = Node.Parse(nodeSample)

printfn &quot;from root&quot;
printfn &quot;%i&quot; (node.Value)
printfn &quot;from item&quot;
printfn &quot;%i&quot; (node.Item.Value)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;In this version, there is no need to build a function to extract and parse the value.
There is no ambigous context between the item and root value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-friend-of-estimation&quot;&gt;The friend of estimation&lt;/h2&gt;

&lt;p&gt;In our team, we analyse complexity to dispatch work by using t-shirt size scale. 
I use fsharp to build a simple fsx with our domain, the data sample of the partner in order to understand their domain (It is not only protocol but domain and business adaptation over the time intervals).&lt;/p&gt;

&lt;p&gt;FSharp.Data speed up the process because the porcelain and plumbing part (xml, json, … all service layer) is done by FSharp.Data and we have a better complexity feedback.
The reason it that sometimes the partner protocol is really verbose and it is harder to navigate into a json or xml than an instanciated object in the interactive mode.&lt;/p&gt;

&lt;p&gt;Before using fsharp.data, I was a System.Xml.Linq ninja :) for estimation purpose, but for now, each time there was a verbose/complex data to understand, I first use a fsharp script.&lt;/p&gt;

&lt;h2 id=&quot;flexibility&quot;&gt;Flexibility&lt;/h2&gt;

&lt;p&gt;When the partner changed his protocol, we have to change the adapter with the new sample and it is really hard to make a diff between 2 samples with completely different data.
So, we add a new test but due to the context problem, it is really hard to see if the change has same name but not the same structure and scope.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If all tests are done, there is only one test for the new protocol and others based on old protocol
If there is a cardinality problem it is really hard to see how it impacts the business part (price scope for example).&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I prefer use fsharp because if there is a new scope (a new node for example), the code will not compile and we have to reason about the whole code.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;How to support both new and old protocols in the same app without error ?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;We need a tool to challenge the existing code with the new protocol&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Here is some example where fsharp data help us to increase the quality and the velocity of our process :&lt;/p&gt;

&lt;p&gt;Like Xml Linq, FSharp.Data is tolerent :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;What about changes that we don’t need :&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#r @&quot;..\packages\FSharp.Data\lib\net40\FSharp.Data.dll&quot;
#r &quot;System.Xml.Linq&quot;

open FSharp.Data

type Node = XmlProvider&amp;lt; &quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;id&amp;gt;50&amp;lt;/id&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot; &amp;gt;

let node = Node.Parse(&quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that the supplied xml to parse method does not have an id element (runtime and design time are different)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The interactive display :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Code : ABC
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Breaking changes at runtime (when the partner break things directly in prod : data differ from the spec at runtime)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#r @&quot;..\packages\FSharp.Data\lib\net40\FSharp.Data.dll&quot;
#r &quot;System.Xml.Linq&quot;

open FSharp.Data

type Node = XmlProvider&amp;lt; &quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;id&amp;gt;50&amp;lt;/id&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot; &amp;gt;

let node = Node.Parse(&quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot;)

printfn &quot;Id : %i&quot; (node.Id)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The code compiles but there was a problem at runtime :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.Exception: XML mismatch: Expected exactly one 'id' child, got 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;For this case, you should consider logging this error with the associated data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Breaking changes on legacy code (quick fix) :&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#r @&quot;..\packages\FSharp.Data\lib\net40\FSharp.Data.dll&quot;
#r &quot;System.Xml.Linq&quot;

open FSharp.Data

type Node = XmlProvider&amp;lt; &quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot; &amp;gt;

let node = Node.Parse(&quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot;)

printfn &quot;Id : %i&quot; (node.Id)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that the required Id (used by the printfn) has been removed from the given sample&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There is an error at design time that we have to fix without adding a new unit test (may be we have to adapt the code without touching test and samples if you want to support both).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When you have to support multiple versions&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#r @&quot;..\packages\FSharp.Data\lib\net40\FSharp.Data.dll&quot;
#r &quot;System.Xml.Linq&quot;
open FSharp.Data

type Node = XmlProvider&amp;lt; &quot;&quot;&quot;
&amp;lt;samples&amp;gt;
&amp;lt;!-- version 1 --&amp;gt;
&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;/root&amp;gt;
&amp;lt;!-- version 2 --&amp;gt;
&amp;lt;root&amp;gt;&amp;lt;productcode&amp;gt;ABC&amp;lt;/productcode&amp;gt;&amp;lt;/root&amp;gt;

&amp;lt;/samples&amp;gt;&quot;&quot;&quot;, SampleIsList=true &amp;gt;

let toResult error = function
    | Some x -&amp;gt; Ok x
    | None -&amp;gt; Error error

let (&amp;lt;|&amp;gt;) x y = 
    match x with
    | Ok x' -&amp;gt; Ok x'
    | Error e1 -&amp;gt;
        match y with 
        | Ok y' -&amp;gt; Ok y'
        | Error e2 -&amp;gt; sprintf &quot;%s\r\nor%s&quot; e1 e2 |&amp;gt; Error

let prettyprint (node:Node.Root) = 
    (node.Code |&amp;gt; toResult &quot;expected code element&quot;) &amp;lt;|&amp;gt; (node.Productcode |&amp;gt; toResult &quot;expected Productcode element&quot;)
	|&amp;gt; printfn &quot;Code : %A&quot;

let nodeLegacy = Node.Parse(&quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot;)
let nodeNew = Node.Parse(&quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;productcode&amp;gt;ABC&amp;lt;/productcode&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot;)

prettyprint nodeLegacy
prettyprint nodeNew
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;I have added the 2 versions in the samples of the XmlProvider by adding a new &lt;samples&gt; root node and the SampleIsList to true parameter. In that case, the XmlProvider skip the first element and consider many child elements to be processed.&lt;/samples&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;I have added 2 functions : the toResult that add the errorMessage when the element is not present and the orElse &lt;code class=&quot;highlighter-rouge&quot;&gt;(&amp;lt;|&amp;gt;)&lt;/code&gt; function to handle the 2 versions. The prettyprint function display the result&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;FSharp.Data uses an erased type provider, so the cost of this abstraction is paid at design time.&lt;/p&gt;

&lt;p&gt;When the application is built, all supplied types (like the type Node in our sample) are discarded.&lt;/p&gt;

&lt;p&gt;So all the abstraction is inlined by a System.Xml.Linq call. The performance is equivalent to the System.Xml.Linq version.&lt;/p&gt;

&lt;p&gt;Our most verbose app that use fsharp.data exchange near 3.000.000 rq/day.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;We have first use a fsharp module on existing csharp apps in order to infer the partner domain&lt;/li&gt;
  &lt;li&gt;The performance are equivalent to a hand made Xml Linq version&lt;/li&gt;
  &lt;li&gt;The estimation part is quicker because it requires less xml linq plumbing&lt;/li&gt;
  &lt;li&gt;Quick fix is possible due to the move from unit test feedback to design time and compiler feedback&lt;/li&gt;
  &lt;li&gt;There was more tests around the domain of our partner and not only on the serialization/deserialization part&lt;/li&gt;
  &lt;li&gt;I have replaced my linqpad + fiddler by fsharp script&lt;/li&gt;
  &lt;li&gt;When the breaking changes are too high, we completely rewrite the adapter by using fsharp and see that the LOC has really decreased (near 40%)&lt;/li&gt;
  &lt;li&gt;The proof of concept code could be reused (better than extracting linqpad code and import to existing + cover code build after unit test)&lt;/li&gt;
  &lt;li&gt;The language ML syntax provide a better way to avoid NRE (Null Reference Exception) when you only deal with fsharp. There is Option.ofObj adapters when object came from csharp.&lt;/li&gt;
  &lt;li&gt;We have started another experience and made our adaptation of the interval valued in full fsharp &lt;a href=&quot;https://github.com/cboudereau/Outatime&quot;&gt;Outatime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">I am currently working at a company that deal with hundreds of connectivities (apps protocol and domain adapters + big data). Since 2014 we have used fsharp data progressively in production (I use fsharp in prod since 2012).</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/images/fsharpdata.jpg" /></entry><entry><title type="html">How to parse a proto3 message with FParsec</title><link href="/fsharp/parser/combinator/fparsec/proto3/2017/08/10/proto3-parser.html" rel="alternate" type="text/html" title="How to parse a proto3 message with FParsec" /><published>2017-08-10T13:13:00+02:00</published><updated>2017-08-10T13:13:00+02:00</updated><id>/fsharp/parser/combinator/fparsec/proto3/2017/08/10/proto3-parser</id><content type="html" xml:base="/fsharp/parser/combinator/fparsec/proto3/2017/08/10/proto3-parser.html">&lt;p&gt;I would like to try &lt;a href=&quot;http://www.quanttec.com/fparsec/&quot;&gt;FParsec&lt;/a&gt; fsharp parser to parse proto3 message.&lt;/p&gt;

&lt;p&gt;I used this &lt;a href=&quot;http://www.quanttec.com/fparsec/&quot;&gt;FParsec&lt;/a&gt; &lt;a href=&quot;http://www.quanttec.com/fparsec/tutorial.html#parsing-json&quot;&gt;tutorial&lt;/a&gt; first in order to be more familiar with this library.
&lt;!--more--&gt;&lt;/p&gt;

&lt;h2 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;This is not a production code
proto3 specification is &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3&quot;&gt;here&lt;/a&gt; if you want to continue with this script.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-proto3-message-sample&quot;&gt;The proto3 message sample&lt;/h2&gt;
&lt;p&gt;proto3 is a message format used by &lt;a href=&quot;https://github.com/mgravell/protobuf-net&quot;&gt;protobuf-net&lt;/a&gt; for example and could be export from type having some attributes indicating the mapping Id &amp;lt;-&amp;gt; properties and other metadata for the serialization configuration.&lt;/p&gt;

&lt;p&gt;For more information about proto spec, read this &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3&quot;&gt;documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To start, I will use this first sample and make step by step all parsers to get the type info in this structure :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Type = 
    | Scalar of string
    | Custom of string

type FieldSpec = 
    { Id : int
      Type: Type
      Name : string }

type Field = 
    | Required of FieldSpec
    | Optional of FieldSpec
    | Repeated of FieldSpec

type Message = 
    { Name : string
      Fields : Field list } 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is the sample that we will use all along this post :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    message CalculateInfo {
    required string CalStarttime=1;
    optional string CalEndtime=2;
    required string Smiles=3;
    optional string CAS=4;
    optional string ChName=5;
    optional string EnName=6;
    required string Param=7;
    required bytes Result=8;
    required bool IsFinished=9;
    required bool IsFinished=9; }

    message GetAllCalulateResponse{
        required bool  isSuccessful = 1;
        required int32 Count=2;
        repeated CalculateInfo History=3; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;lets-go-&quot;&gt;Lets go !&lt;/h2&gt;
&lt;p&gt;The FParsec references (I will write with REPL style, so I will use a .fsx).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#I __SOURCE_DIRECTORY__
#r &quot;packages/FParsec/lib/net40-client/FParsecCS.dll&quot;
#r &quot;packages/FParsec/lib/net40-client/FParsec.dll&quot;
#r &quot;System.Core.dll&quot;
#r &quot;System.dll&quot;
#r &quot;System.Drawing.dll&quot;
#r &quot;System.Numerics.dll&quot;

open FParsec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;step-1--extracting-the-name-of-the-message&quot;&gt;Step 1 : extracting the name of the message&lt;/h2&gt;
&lt;p&gt;In our case we want to extract the first message name : CalculateInfo&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let msgSample = &quot;message CalculateInfo {&quot;

let pMessage = spaces &amp;gt;&amp;gt;. pstringCI &quot;message&quot; &amp;gt;&amp;gt;. spaces &amp;gt;&amp;gt;. (noneOf &quot;{ &quot; |&amp;gt; manyChars) 

run pMessage msgSample
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The pMessage function will :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;skip any spaces (including line break),&lt;/li&gt;
  &lt;li&gt;parse the world (case insensitive) “message”,&lt;/li&gt;
  &lt;li&gt;skip any spaces&lt;/li&gt;
  &lt;li&gt;extract any chars (manyChars will convert chars to string) except (noneOf take a string and extract each char as blacklist) “ “ (whitespace) and “{“.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The interactive will print this result :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val it : ParserResult&amp;lt;string,unit&amp;gt; = Success: &quot;CalculateInfo&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;step-2--parse-1-field&quot;&gt;Step 2 : Parse 1 field&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let fieldSample = &quot;required string CalStarttime=1&quot;

let fieldSpec f t n i = f { FieldSpec.Id=i; Type=t; Name=n }
let pRequired = stringCIReturn &quot;required&quot; (fieldSpec Required)

run pRequired fieldSample
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The pRequired will parse the word (case insensitive) required and return the fieldSpec with the parameter Required.
Let see the fieldSpec func : f parameter could be one of the choice defined into the type :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Field = 
    | Required of FieldSpec
    | Optional of FieldSpec
    | Repeated of FieldSpec
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;When we look at the proto3 field definition we will parse in order :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;required string CalStarttime=1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;1/ Field rule
2/ Type
3/ Name 
4/ Id&lt;/p&gt;

&lt;p&gt;Look at the fieldSpec fun (defined in the previous code part) is exactly the adapter function that parsing after parsing will be applied to become in the end a Field instance.&lt;/p&gt;

&lt;p&gt;Let just adapt the parser in order to parse the field rules optional or repeated :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let ws = pchar ' ' |&amp;gt; manyChars |&amp;gt;&amp;gt; ignore

let fieldSample = &quot;required string CalStarttime=1&quot;

let fieldSpec f t n i = f { FieldSpec.Id=i; Type=t; Name=n }
let pRequired = stringCIReturn &quot;required&quot; (fieldSpec Required)
let pOptional = stringCIReturn &quot;optional&quot; (fieldSpec Optional)
let pRepeated = stringCIReturn &quot;repeated&quot; (fieldSpec Repeated)
let pField = ws &amp;gt;&amp;gt;. (pRequired &amp;lt;|&amp;gt; pOptional &amp;lt;|&amp;gt; pRepeated)

run pField &quot;required string CalStarttime=1&quot; //Success: &amp;lt;fun:pRequired@40-8&amp;gt;
run pField &quot;repeated string CalStarttime=1&quot; //Success: &amp;lt;fun:pRepeated@42-6&amp;gt;
run pField &quot;optional string CalStarttime=1&quot; //Success: &amp;lt;fun:pOptional@41-6&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can see that the orElse operator &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;|&amp;gt;&lt;/code&gt; return the parser corresponding to the field rule (optional, required, repeated).&lt;/p&gt;

&lt;p&gt;Now we have a function that take only the type, name and id.&lt;/p&gt;

&lt;p&gt;Let’s go to parse the type!&lt;/p&gt;

&lt;p&gt;In proto, types are separated as scalar type and other types.&lt;/p&gt;

&lt;p&gt;We will first parse the scalar type.
The code is a little bit boring, the most interesting part is the parser function :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module ScalarType = 
    let private mapping = 
        [ &quot;double&quot;,  typeof&amp;lt;double&amp;gt;
          &quot;float&quot;,   typeof&amp;lt;float&amp;gt;
          &quot;int32&quot;,   typeof&amp;lt;int&amp;gt;
          &quot;int64&quot;,   typeof&amp;lt;int64&amp;gt;
          &quot;uint32&quot;,  typeof&amp;lt;uint32&amp;gt;
          &quot;uint64&quot;,  typeof&amp;lt;uint64&amp;gt;
          &quot;sint32&quot;,  typeof&amp;lt;int32&amp;gt;
          &quot;sint64&quot;,  typeof&amp;lt;int64&amp;gt;
          &quot;fixed32&quot;, typeof&amp;lt;uint32&amp;gt;
          &quot;fixed64&quot;, typeof&amp;lt;uint64&amp;gt;
          &quot;sfixed32&quot;,typeof&amp;lt;int32&amp;gt;
          &quot;sfixed64&quot;,typeof&amp;lt;int64&amp;gt;
          &quot;bool&quot;,    typeof&amp;lt;bool&amp;gt;
          &quot;string&quot;,  typeof&amp;lt;string&amp;gt;
          &quot;bytes&quot;,   typeof&amp;lt;byte[]&amp;gt; ]
        |&amp;gt; Map.ofList

    let parser = 
        mapping
        |&amp;gt; Map.toSeq
        |&amp;gt; Seq.map (fst &amp;gt;&amp;gt; pstring)
        |&amp;gt; Seq.fold (&amp;lt;|&amp;gt;) pzero
		
run ScalarType.parser &quot;double&quot; //ParserResult&amp;lt;string,unit&amp;gt; = Success: &quot;double&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The parser function aim :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;take all scalar type as string into a seq.&lt;/li&gt;
  &lt;li&gt;for each string, use a string parser&lt;/li&gt;
  &lt;li&gt;use the orElse combinator and start with the pzero.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The pzero is really intesting because it will always return Error with empty error message. 
Combined with the orElse combinator it is like if you just force the second parser to be executed because the first parser will always failed.
This is exactly what we want when we would like to fold the sequence of parsers to one parser.&lt;/p&gt;

&lt;p&gt;What is displayed if there was an error ?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;run ScalarType.parser &quot;hello&quot; (*val it : ParserResult&amp;lt;string,unit&amp;gt; =
  Failure:
Error in Ln: 1 Col: 1
hello
^
Expecting: 'bool', 'bytes', 'double', 'fixed32', 'fixed64', 'float', 'int32',
'int64', 'sfixed32', 'sfixed64', 'sint32', 'sint64', 'string', 'uint32' or
'uint64'*)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hey! not bad!&lt;/p&gt;

&lt;p&gt;If it is not a scalar type, it is a custom type :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let pWord = (&amp;lt;&amp;gt;) ' ' |&amp;gt; satisfy |&amp;gt; manyChars

let pType = 
    (ScalarType.parser |&amp;gt;&amp;gt; Scalar)
    &amp;lt;|&amp;gt; (ws &amp;gt;&amp;gt;. pWord |&amp;gt;&amp;gt; Custom)
	
run pType &quot;hello&quot; //ParserResult&amp;lt;Type,unit&amp;gt; = Success: Custom &quot;hello&quot;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;There is only the name and identifier missed to build the full field parser, so here is the full code of the field parser :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let (&amp;lt;*&amp;gt;) f x = f &amp;gt;&amp;gt;= fun f' -&amp;gt; x &amp;gt;&amp;gt;= fun x' -&amp;gt; preturn (f' x')

let pField = 
    let fieldSpec f t n i = f { Id=i; Type=t; Name=n }
    let pRequired = stringCIReturn &quot;required&quot; (fieldSpec Required)
    let pOptional = stringCIReturn &quot;optional&quot; (fieldSpec Optional)
    let pRepeated = stringCIReturn &quot;repeated&quot; (fieldSpec Repeated)
    let pField = ws &amp;gt;&amp;gt;. (pRequired &amp;lt;|&amp;gt; pOptional &amp;lt;|&amp;gt; pRepeated)
    
    let pName = ws &amp;gt;&amp;gt;. (noneOf &quot; =&quot; |&amp;gt; manyChars)
    let pId = ws &amp;gt;&amp;gt;. pstring &quot;=&quot; &amp;gt;&amp;gt;. spaces &amp;gt;&amp;gt;. pint32

    pField &amp;lt;*&amp;gt; (ws &amp;gt;&amp;gt;. pType) &amp;lt;*&amp;gt; (ws &amp;gt;&amp;gt;. pName) &amp;lt;*&amp;gt; pId

run pField &quot;required string CalStarttime=1&quot; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The result will be :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val it : ParserResult&amp;lt;Field,unit&amp;gt; =
  Success: Required {Id = 1;
          Type = Scalar &quot;string&quot;;
          Name = &quot;CalStarttime&quot;;}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Now we have to build a fields parser that parse multiple field !&lt;/p&gt;

&lt;h2 id=&quot;step-3--parsing-n-fields&quot;&gt;Step 3 : Parsing n Fields&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let pFields = spaces &amp;gt;&amp;gt;. sepEndBy pField (spaces &amp;gt;&amp;gt;. pchar ';' .&amp;gt;&amp;gt; spaces)

run pFields &quot;&quot;&quot;required string CalStarttime=1;optional string CalEndtime=2&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;with more samples :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;run pFields &quot;&quot;&quot;required string CalStarttime=1; optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;required string CalStarttime=1 ; optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;
required string CalStarttime=1 ; optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;
 required string CalStarttime=1 ; optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;
    required string CalStarttime=1 ; optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;
    required string CalStarttime=1;
    optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;
    required string CalStarttime=1;
    optional string CalEndtime=2;
    
    &quot;&quot;&quot;
run pFields &quot;&quot;&quot;


    required string CalStarttime=1;
    optional string CalEndtime=2;
    
    &quot;&quot;&quot;
run pFields &quot;&quot;&quot;


    required string CalStarttime=1;

    optional string CalEndtime=2;
    
    &quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;step-final--the-full-parser&quot;&gt;Step final : the full parser&lt;/h2&gt;
&lt;p&gt;And now we have to combine pFields + pMessge together!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let message name fields = { Fields=fields; Name=name }

let pProtoMessage = pMessage |&amp;gt;&amp;gt; message .&amp;gt;&amp;gt; spaces .&amp;gt;&amp;gt; pchar '{' .&amp;gt;&amp;gt; spaces &amp;lt;*&amp;gt; pFields .&amp;gt;&amp;gt; spaces .&amp;gt;&amp;gt; pchar '}'

let pProtos = sepEndBy pProtoMessage spaces

run pProtos &quot;&quot;&quot;
    message CalculateInfo {
    required string CalStarttime=1;
    optional string CalEndtime=2;
    required string Smiles=3;
    optional string CAS=4;
    optional string ChName=5;
    optional string EnName=6;
    required string Param=7;
    required bytes Result=8;
    required bool IsFinished=9;
    required bool IsFinished=9; }

    message GetAllCalulateResponse{
        required bool  isSuccessful = 1;
        required int32 Count=2;
        repeated CalculateInfo History=3; }
&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And the final result of our parser!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val it : ParserResult&amp;lt;Field list,unit&amp;gt; =
  Success: [Required {Id = 1;
           Type = Scalar &quot;string&quot;;
           Name = &quot;CalStarttime&quot;;}; Optional {Id = 2;
                                              Type = Scalar &quot;string&quot;;
                                              Name = &quot;CalEndtime&quot;;}]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, we see step by step how to deal with FParsec to build and compose parser together by building a full proto message parser.
This parser could be composed with an enum parser. The enum parser could reuse the internal message parser, and so on…&lt;/p&gt;</content><author><name></name></author><summary type="html">I would like to try FParsec fsharp parser to parse proto3 message. I used this FParsec tutorial first in order to be more familiar with this library.</summary></entry><entry><title type="html">Parser Combinator in real life</title><link href="/fsharp,/parser/combinator/2017/08/09/why-parser.html" rel="alternate" type="text/html" title="Parser Combinator in real life" /><published>2017-08-09T13:14:01+02:00</published><updated>2017-08-09T13:14:01+02:00</updated><id>/fsharp,/parser/combinator/2017/08/09/why-parser</id><content type="html" xml:base="/fsharp,/parser/combinator/2017/08/09/why-parser.html">&lt;p&gt;I had to write an application that handle 2200 msg per second. 
This application consist of indexing and compress data with 7z.&lt;/p&gt;

&lt;p&gt;And here is why I use a parser combinator.
&lt;!--more--&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I will write another post for the usage of the awesome &lt;a href=&quot;https://github.com/zeromq/fszmq&quot;&gt;fszmq&lt;/a&gt; and a custom interop of 7z in a later post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;I attempted to use Linq to xml that load entirely the document element by element in memory causing LOH (on data that I don’t want to index) problem when a big element is loaded.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The XmlProvider is based on Linq so I had the same problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Both are very usefull and the usage of parser combinator is overkill when there is no reason :)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;All my documents consist of a xml document that contains information to store and organize for indexation process and other data to just forward (to the 7z zipper part).&lt;/p&gt;

&lt;p&gt;2 elements of the xml contain logs of partners request/response data. 
Those 2 elements could have more than 10MB and I don’t want to load this kind of message entirely due to LOH + GC problems (avg is near 1200msg/s :)).&lt;/p&gt;

&lt;p&gt;When I check the linq to xml implementation, it load the document entirely element by element in memory with the XmlReader.&lt;/p&gt;

&lt;p&gt;So, I first wrote a simple code that use the XmlReader but :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I don’t know when this XmlReader read or not the data.&lt;/li&gt;
  &lt;li&gt;It is hard to have a clean context&lt;/li&gt;
  &lt;li&gt;But it works!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After 2 weeks in production, I discover a new corner case like this :&lt;/p&gt;

&lt;p&gt;An Id could be represent as&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;root&amp;gt;
&amp;lt;Id&amp;gt;1&amp;lt;/Id&amp;gt;
&amp;lt;Request&amp;gt;Big Data here !&amp;lt;/Request&amp;gt;
&amp;lt;Response&amp;gt;Big Data here !&amp;lt;/Response&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;root&amp;gt;
&amp;lt;Id&amp;gt;0&amp;lt;/Id&amp;gt;
&amp;lt;items&amp;gt;&amp;lt;item&amp;gt;&amp;lt;Id&amp;gt;1&amp;lt;/Id&amp;gt;&amp;lt;Request&amp;gt;Big Data here !&amp;lt;/Request&amp;gt;&amp;lt;Response&amp;gt;Big Data here !&amp;lt;/Response&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;/items&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I remember how Linq and FSharp.Data were very usefull in this case but for the performance reason it is not ok!&lt;/p&gt;

&lt;p&gt;After dealing with if/else/pattern matching approach, I tried Parser Combinator style.
Instead parsing char, the context used by the parser is the XmlReader.
I don’t want to rewrite a full xml parser because parsing xml is too hard and XmlReader is ok for that point.&lt;/p&gt;

&lt;h2 id=&quot;a-solution-in-functional-style&quot;&gt;A Solution in Functional style&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;I have to index a lots of document so compose a parser should be easy
The solution should offer a maximum of flexibility to compose things together&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I would like to express code like this :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Entry = { Id:string } 
let convert message = 
	use reader = XmlReader.Create(message:Stream)
	let entry id = { Id=id }
	let entryP = ffwd &quot;Id&quot; &amp;gt;&amp;gt;. element (id &amp;gt;&amp;gt; Ok) &quot;Id&quot;
	run reader entryP
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The Parser type that wrap the parser function.
The aim of parser function is like an interface but instead it hide the context and error types&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Parser&amp;lt;'x, 'a&amp;gt; = Parser of ('x -&amp;gt; Result&amp;lt;'a, string list&amp;gt;) 
let run context (Parser p) = p context
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Where ‘x could be the XmlReader and the run function that just unwrap the parser function and apply the given context.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;.&lt;/code&gt; is an operator that takes 2 parser and return the result of the right parser. 
If you understand the meaning of the point you should intuitively understand that the &lt;code class=&quot;highlighter-rouge&quot;&gt;.&amp;gt;&amp;gt;&lt;/code&gt; do the same except that it return the left result
&lt;code class=&quot;highlighter-rouge&quot;&gt;.&amp;gt;&amp;gt;.&lt;/code&gt; return both left and right result.&lt;/p&gt;

&lt;p&gt;Quite Simple !&lt;/p&gt;

&lt;p&gt;the full parser code based on XmlReader&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Parser&amp;lt;'x, 'a&amp;gt; = Parser of ('x -&amp;gt; Result&amp;lt;'a, string list&amp;gt;) 

//The code is based on the latest fsharp 4.1 (install vs2017 + fsharp 4.1 for eg)
open Result

let run context (Parser p) = p context
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Define a map function that&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Execute the parser x&lt;/li&gt;
  &lt;li&gt;If is ok, the parser x return a x’ result. Just apply x’ to f and return Ok&lt;/li&gt;
  &lt;li&gt;Stop if there is an error and do not apply f (show the error string list for exemple)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let map f x = 
    fun reader -&amp;gt;
        match run reader x with
        | Ok x' -&amp;gt; f x' |&amp;gt; Ok
        | Error e -&amp;gt; Error e
    |&amp;gt; Parser

let (&amp;lt;!&amp;gt;) = map
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Define an apply function that do&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Execute the run on the reader context on f and x&lt;/li&gt;
  &lt;li&gt;if parsers f and x in sequence return both ok then return Ok f’ x’&lt;/li&gt;
  &lt;li&gt;Like map stop on error&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let apply f x = 
    fun reader -&amp;gt;
        match run reader f, run reader x with
        | Ok f', Ok x' -&amp;gt; Ok (f' x')
        | Error e, _ | _, Error e -&amp;gt; Error e
    |&amp;gt; Parser

let (&amp;lt;*&amp;gt;) = apply
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The famous so called “combinator” function that&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Parse x and y in sequence and return one or both depending on the “.” on operator&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// return y result if x and y are Ok in sequence
let (&amp;gt;&amp;gt;.) x y = 
    fun reader -&amp;gt;
        match run reader x with
        | Ok _ -&amp;gt; run reader y
        | Error e -&amp;gt; Error e
    |&amp;gt; Parser

/// return x result if x and y are Ok in sequence
let (.&amp;gt;&amp;gt;) x y = 
    fun reader -&amp;gt;
        match run reader x with
        | Ok x' -&amp;gt; 
            match run reader y with
            | Ok _ -&amp;gt; Ok x'
            | Error e -&amp;gt; Error e
        | Error e -&amp;gt; Error e
    |&amp;gt; Parser

/// return (x, y) as struct results if x and y are Ok in sequence
let (.&amp;gt;&amp;gt;.) x y = 
    fun reader -&amp;gt;
        match run reader x with
        | Ok x' -&amp;gt; 
            match run reader y with
            | Ok y' -&amp;gt; Ok (struct(x', y'))
            | Error e -&amp;gt; Error e
        | Error e -&amp;gt; Error e
    |&amp;gt; Parser
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The aim of many function is like an unfold on List, 
so while there is no error aggregate result to a list and return the list on the first error&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let many x = 
    fun reader -&amp;gt;
        List.unfold 
            &amp;lt;| fun reader -&amp;gt; match run reader x with Ok x' -&amp;gt; Some (x', reader) | Error _ -&amp;gt; None
            &amp;lt;| reader
        |&amp;gt; Ok

   |&amp;gt; Parser
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The orElse combinator is like a branch condition, if x has an error then run y.
But if x is ok, just return x without running y&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let orElse x y = 
    fun reader -&amp;gt;
        match run reader x with
        | Ok x' -&amp;gt; Ok x'
        | Error e1 -&amp;gt; 
            match run reader y with
            | Ok y' -&amp;gt; Ok y'
            | Error e2 -&amp;gt; Error (List.append e1 e2)
    |&amp;gt; Parser

let (&amp;lt;|&amp;gt;) = orElse
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Ok now I have the abstraction to parse any context.&lt;/p&gt;

&lt;p&gt;Remember that my context is the XmlReader&lt;/p&gt;

&lt;p&gt;The Xml helper function&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open System.Xml
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Hey it is xml :)&lt;/p&gt;

&lt;p&gt;I Have to deal with XmlReader that confuse technical error with business error with the same way…
So lets go to catch!&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let tryF name f (reader:XmlReader) = 
    try
        f reader
    with ex -&amp;gt; Error [sprintf &quot;expected %s got an error:\r\n%O&quot; name ex]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The ffwd just fast forward the XmlReader to the given name&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let ffwd name = 
    fun (reader:XmlReader) -&amp;gt; 
        while reader.Name &amp;lt;&amp;gt; name &amp;amp;&amp;amp; not reader.EOF &amp;amp;&amp;amp; reader.Read() do ()
        |&amp;gt; Ok
    |&amp;gt; Parser
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The element function read the element with the given name, and apply the function f to the content&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let element f name = 
    tryF name &amp;lt;| fun reader -&amp;gt;
        reader.ReadStartElement(name)
        if reader.NodeType = XmlNodeType.Text then
            let result = f (reader.ReadContentAsString())
            reader.ReadEndElement()
            result 
        else 
            let result = f &quot;&quot;
            if reader.NodeType = XmlNodeType.EndElement then reader.ReadEndElement()
            result
    |&amp;gt; Parser
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The nested function treat the nested element case like :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;item&amp;gt;...&amp;lt;/item&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let nested name p = 
    tryF name &amp;lt;| fun reader -&amp;gt;
        reader.ReadStartElement(name)
        let result = run reader p
        reader.ReadEndElement()
        result
    |&amp;gt; Parser
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The pIgnore skip an element and return unit (very usefull with .» pIgnore or pIgnore ».)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let pIgnore = 
    fun (reader:XmlReader) -&amp;gt; 
        reader.ReadStartElement()
        reader.Skip()
        reader.ReadEndElement()
        Ok ()
    |&amp;gt; Parser 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;some-examples&quot;&gt;Some Examples&lt;/h2&gt;
&lt;p&gt;A sample parser implementation :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open System 
open System.IO

type Entry = 
    { Keys: string Set
      Date : DateTime 
      Data: Stream }

let convert (message:Stream) = 
    let reader = XmlReader.Create(new StreamReader(message))
    let elt f x = element (f &amp;gt;&amp;gt; Ok) x
    let strE x = elt id x
    let ffwdE x f = ffwd x &amp;gt;&amp;gt;. element (f &amp;gt;&amp;gt; Ok) x
    let pIsSuccess = ffwdE &quot;MessageType&quot; ((&amp;lt;&amp;gt;) &quot;Failed&quot;)

    let pHid = ffwdE &quot;HotelId&quot; int
    let pGid = elt int &quot;GroupId&quot;
    
    let parseDate s = 
        System.DateTime.Parse(s, Globalization.CultureInfo.InvariantCulture, Globalization.DateTimeStyles.AssumeUniversal).ToUniversalTime()

    let pDate = elt parseDate &quot;Date&quot;
    
    let pStartDate = ffwdE &quot;Start&quot; parseDate
    let pEndDate = elt parseDate &quot;End&quot;

    let pRoomCode = strE &quot;RoomCode&quot;
    let pRoomId = elt int &quot;RoomId&quot;
    
    let pRooms = 
        let zero = 
            fun _ -&amp;gt; Ok Set.empty
            |&amp;gt; Parser

        let nestedO name p = nested name p &amp;lt;|&amp;gt; zero  
        let pItem = pRoomCode .&amp;gt;&amp;gt;. pRoomId
        let pItems = set &amp;lt;!&amp;gt; (many (nested &quot;item&quot; pItem))
        ffwd &quot;Rooms&quot; &amp;gt;&amp;gt;. nestedO &quot;Rooms&quot; pItems
    
    let pRoom = Set.singleton &amp;lt;!&amp;gt; (ffwd &quot;RoomCode&quot; &amp;gt;&amp;gt;. pRoomCode .&amp;gt;&amp;gt;. pRoomId)

    let roomIdsP = 
        let defaultTo x y = 
            match y with _ when y |&amp;gt; Set.isEmpty -&amp;gt; x | _ -&amp;gt; y 

        defaultTo &amp;lt;!&amp;gt; pRoom &amp;lt;*&amp;gt; pRooms

    let logEntry (message:Stream) isSuccess hotelId groupId stamp startDate endDate rooms = 
        let ssnd (struct (_,x)) = x
        let roomIds = rooms |&amp;gt; Set.map ssnd
        let key = sprintf &quot;%i/%i/%i&quot;
        let keys = roomIds |&amp;gt; Set.map(key groupId hotelId)
        { Keys = keys
          Date = stamp
          Data = 
            message.Position &amp;lt;- 0L
            message }
    
    let rawXml (message:Stream) = 
        message.Position &amp;lt;- 0L
        let sr = new StreamReader(message)
        sr.ReadToEnd()

    try
        match run reader (logEntry message &amp;lt;!&amp;gt; pIsSuccess &amp;lt;*&amp;gt; pHid &amp;lt;*&amp;gt; pGid &amp;lt;*&amp;gt; pDate &amp;lt;*&amp;gt; pStartDate &amp;lt;*&amp;gt; pEndDate &amp;lt;*&amp;gt; roomIdsP) with
        | Ok logEntry -&amp;gt; Some logEntry
        | Error errors -&amp;gt; 
            let error = System.String.Join(System.Environment.NewLine, errors |&amp;gt; Array.ofList)
            printfn &quot;[WARN]%s\r\nXml :\r\n%s&quot; error (rawXml message)
            None
    with ex -&amp;gt; failwithf &quot;Parsing failed with error %O\r\nXml:\r\n%s&quot; ex (rawXml message)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I love this kind of little and composable declaration.
Parsing is now like a Lego game!&lt;/p&gt;

&lt;p&gt;The associated tests :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;///Porcelain and plumbing
let convertFromString x = 
    use s = new MemoryStream()
    use sw = new StreamWriter(s)
    sw.Write(x:string)
    sw.Flush()
    s.Position &amp;lt;- 0L
    convert s

convertFromString &quot;&quot;&quot;
&amp;lt;Transport&amp;gt;&amp;lt;DestinationUri&amp;gt;dest&amp;lt;/DestinationUri&amp;gt;&amp;lt;SourceUri&amp;gt;source&amp;lt;/SourceUri&amp;gt;&amp;lt;ReplyUri /&amp;gt;&amp;lt;MessageType&amp;gt;Update&amp;lt;/MessageType&amp;gt;&amp;lt;Message&amp;gt;&amp;lt;HotelId&amp;gt;3116&amp;lt;/HotelId&amp;gt;&amp;lt;GroupId&amp;gt;9358&amp;lt;/GroupId&amp;gt;&amp;lt;Date&amp;gt;2017-02-20T16:19:12.4037606Z&amp;lt;/Date&amp;gt;&amp;lt;Request&amp;gt;Big Request&amp;lt;/Request&amp;gt;&amp;lt;Response&amp;gt;Big Response&amp;lt;/Response&amp;gt;&amp;lt;Start&amp;gt;2017-03-02&amp;lt;/Start&amp;gt;&amp;lt;End&amp;gt;2017-03-03&amp;lt;/End&amp;gt;
    &amp;lt;RoomCode&amp;gt;26757&amp;lt;/RoomCode&amp;gt;
    &amp;lt;RoomId&amp;gt;7066&amp;lt;/RoomId&amp;gt;
    &amp;lt;Rooms /&amp;gt;&amp;lt;/Message&amp;gt;&amp;lt;/Transport&amp;gt;
&quot;&quot;&quot;

/// Do not consider the first Single RoomId if equal 0 and if there is no RoomIds
convertFromString &quot;&quot;&quot;
&amp;lt;Transport&amp;gt;&amp;lt;DestinationUri&amp;gt;dest&amp;lt;/DestinationUri&amp;gt;&amp;lt;SourceUri&amp;gt;source&amp;lt;/SourceUri&amp;gt;&amp;lt;ReplyUri /&amp;gt;&amp;lt;MessageType&amp;gt;Update&amp;lt;/MessageType&amp;gt;&amp;lt;Message&amp;gt;&amp;lt;HotelId&amp;gt;3116&amp;lt;/HotelId&amp;gt;&amp;lt;GroupId&amp;gt;9358&amp;lt;/GroupId&amp;gt;&amp;lt;Date&amp;gt;2017-02-20T16:19:12.4037606Z&amp;lt;/Date&amp;gt;&amp;lt;Request&amp;gt;Big Request&amp;lt;/Request&amp;gt;&amp;lt;Response&amp;gt;Big Response&amp;lt;/Response&amp;gt;&amp;lt;Start&amp;gt;2017-03-02&amp;lt;/Start&amp;gt;&amp;lt;End&amp;gt;2017-03-03&amp;lt;/End&amp;gt;
    &amp;lt;RoomCode /&amp;gt;
    &amp;lt;RoomId&amp;gt;0&amp;lt;/RoomId&amp;gt;
    &amp;lt;Rooms&amp;gt;
        &amp;lt;item&amp;gt;
            &amp;lt;RoomCode&amp;gt;16239&amp;lt;/RoomCode&amp;gt;
            &amp;lt;RoomId&amp;gt;3347&amp;lt;/RoomId&amp;gt;
        &amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;
            &amp;lt;RoomCode&amp;gt;16241&amp;lt;/RoomCode&amp;gt;
            &amp;lt;RoomId&amp;gt;3346&amp;lt;/RoomId&amp;gt;
        &amp;lt;/item&amp;gt;
   &amp;lt;/Rooms&amp;gt;&amp;lt;/Message&amp;gt;&amp;lt;/Transport&amp;gt;
&quot;&quot;&quot;

/// Use the RoomId 0 = All Rooms when the is empty RoomIds
convertFromString &quot;&quot;&quot;
&amp;lt;Transport&amp;gt;&amp;lt;DestinationUri&amp;gt;dest&amp;lt;/DestinationUri&amp;gt;&amp;lt;SourceUri&amp;gt;source&amp;lt;/SourceUri&amp;gt;&amp;lt;ReplyUri /&amp;gt;&amp;lt;MessageType&amp;gt;Update&amp;lt;/MessageType&amp;gt;&amp;lt;Message&amp;gt;&amp;lt;HotelId&amp;gt;3116&amp;lt;/HotelId&amp;gt;&amp;lt;GroupId&amp;gt;9358&amp;lt;/GroupId&amp;gt;&amp;lt;Date&amp;gt;2017-02-20T16:19:12.4037606Z&amp;lt;/Date&amp;gt;&amp;lt;Request&amp;gt;Big Request&amp;lt;/Request&amp;gt;&amp;lt;Response&amp;gt;Big Response&amp;lt;/Response&amp;gt;&amp;lt;Start&amp;gt;2017-03-02&amp;lt;/Start&amp;gt;&amp;lt;End&amp;gt;2017-03-03&amp;lt;/End&amp;gt;
    &amp;lt;RoomCode /&amp;gt;
    &amp;lt;RoomId&amp;gt;0&amp;lt;/RoomId&amp;gt;
    &amp;lt;/Message&amp;gt;&amp;lt;/Transport&amp;gt;
&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;the-pros&quot;&gt;The pros&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Easy to write&lt;/li&gt;
  &lt;li&gt;Easy to maintain&lt;/li&gt;
  &lt;li&gt;Hey it is composition, I can reuse parser and compose them to create new one!&lt;/li&gt;
  &lt;li&gt;It fix a real issue (I start writing a code that parse xml with XmlReader with hard issue to solve in existing code)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-cons&quot;&gt;The cons&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;It was my first attempt, so the first parser was harder to write but others were very easy to compose (The most part was to understand how works XmlReader and when the context has changed or not!)&lt;/li&gt;
  &lt;li&gt;The use of operator and applicative separate the definition of the function from its execution. When you are debugging the run function you have to deal with a stack containing operator name (like GreaterGreaterEqual). Inlining the operator could help but it is more difficult to debug.&lt;/li&gt;
  &lt;li&gt;For now, in my experience, I delivered multiple fix / multiple parsers composition and it is not a big deal to change my habits, finally it was easy to fix and maintain.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In &lt;a href=&quot;/fsharp/parser/combinator/fparsec/proto3/2017/08/10/proto3-parser.html&quot;&gt;this post&lt;/a&gt; I will introduce &lt;a href=&quot;http://www.quanttec.com/fparsec/&quot;&gt;FParsec&lt;/a&gt; in order to parse proto3 file.&lt;/p&gt;

&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/&quot;&gt;Understanding Parser Combinators/Scott Wlaschin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.haskell.org/Monad&quot;&gt;Monad/Haskell wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">I had to write an application that handle 2200 msg per second. This application consist of indexing and compress data with 7z. And here is why I use a parser combinator.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/images/parsercombinator.png" /></entry></feed>