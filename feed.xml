<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.5.1">Jekyll</generator><link href="https://cboudereau.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://cboudereau.github.io//" rel="alternate" type="text/html" /><updated>2017-08-17T15:21:31+02:00</updated><id>https://cboudereau.github.io//</id><title type="html">Yet Another Geek Blog</title><subtitle>Yet Another Geek Blog : dev with fun(ction)
</subtitle><entry><title type="html">Why we use fsharp data in prod</title><link href="https://cboudereau.github.io//fsharp/data/prod/2017/08/17/why-we-use-fsharp-data-in-prod.html" rel="alternate" type="text/html" title="Why we use fsharp data in prod" /><published>2017-08-17T13:04:00+02:00</published><updated>2017-08-17T13:04:00+02:00</updated><id>https://cboudereau.github.io//fsharp/data/prod/2017/08/17/why-we-use-fsharp-data-in-prod</id><content type="html" xml:base="https://cboudereau.github.io//fsharp/data/prod/2017/08/17/why-we-use-fsharp-data-in-prod.html">&lt;p&gt;Actually, I work for a company that deal with hundreds of connectivities.&lt;/p&gt;

&lt;p&gt;We have since 2014 used fsharp data progressively in production.&lt;/p&gt;

&lt;p&gt;Today we have more than 10% and 1 of the top 3 (top business, high performance) in prod plus a custom big data solution in full fsharp (zmq + 7z + Azure)&lt;/p&gt;

&lt;p&gt;We use fsharp data into different stages of a project : estimation, proof of concept, dev&lt;/p&gt;

&lt;h2 id=&quot;our-context&quot;&gt;Our context&lt;/h2&gt;

&lt;p&gt;A connectivity is an adapter to exchange data with a partner.
This partner use often a “standard”. This standard &lt;a href=&quot;http://opentravel.org/#sthash.4w8LbhfH.dpbs&quot;&gt;OTA&lt;/a&gt; try to unify the communication between two partner. The bad news is : everything in OTA is optional.&lt;/p&gt;

&lt;p&gt;What’s the problem ?&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Every partner has his own set of required and optional data.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Values are defined on an interval (another post could be dedicated to this part) and each partner has his own interval valued scope&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Some partner does not use OTA anymore or they don’t know that OTA exists (due to historical reason, …)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Even if the partner has a poor interface, we have to integrate it has quick as possible&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;code-analysis-on-our-existing-apps&quot;&gt;Code analysis on our existing apps&lt;/h2&gt;
&lt;p&gt;When I was arrived in this company, I had ran &lt;a href=&quot;http://www.ndepend.com/&quot;&gt;NDepend&lt;/a&gt; and &lt;a href=&quot;https://www.sonarqube.org/&quot;&gt;Sonar&lt;/a&gt; to see :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;how modules are dependent (visualize and navigate to the graph)&lt;/li&gt;
  &lt;li&gt;how many lines of codes depend on a module&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each connector has around 35% of codes that use &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Xml.Linq&lt;/code&gt; and 50% of tests are dedicated to serialization/deserialization part.&lt;/p&gt;

&lt;h2 id=&quot;maintenability&quot;&gt;Maintenability&lt;/h2&gt;
&lt;p&gt;When we have to fix an existing app, we have to add a test, run the test and see where there was a problem.
It is really boring and the partner will often break there compatibility.&lt;/p&gt;

&lt;p&gt;When we build a new connector, with xml linq we have in the end a lot of method like this :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static Stuff BuildStuff(XDocument responseXml, XElement name)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Passing &lt;code class=&quot;highlighter-rouge&quot;&gt;XElement&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;XDocument&lt;/code&gt;, any xml linq parameter does not supply the context : the what. We have constantly to dev with the sample to the right side because it is totally dynamic.&lt;/p&gt;

&lt;p&gt;When I analyse this kind of code it is really hard to analyse the code without the sample and the big picture.&lt;/p&gt;

&lt;p&gt;Here is an example :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;node&amp;gt;

	&amp;lt;item&amp;gt;
		&amp;lt;value&amp;gt;10&amp;lt;/value&amp;gt;
	&amp;lt;/item&amp;gt;
	&amp;lt;value&amp;gt;100&amp;lt;/value&amp;gt;

&amp;lt;/node&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;the associated code that get all values:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Program
{
	private static IEnumerable&amp;lt;decimal&amp;gt; Values(XElement x)
	{
		return x.Descendants(&quot;value&quot;).Select(y =&amp;gt; Decimal.Parse(y.Value));
	}
	static void Main(string[] args)
	{
		var xml = XDocument.Parse(@&quot;&amp;lt;node&amp;gt;&amp;lt;item&amp;gt;&amp;lt;value&amp;gt;10&amp;lt;/value&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;value&amp;gt;100&amp;lt;/value&amp;gt;&amp;lt;/node&amp;gt;&quot;);

		var v1 = Values(xml.Root);
		var v2 = Values(xml.Descendants(&quot;item&quot;).First());

		Console.WriteLine(&quot;from root&quot;);
		v1.ToList().ForEach(x =&amp;gt; Console.WriteLine(&quot;value : {0}&quot;, x));

		Console.WriteLine(&quot;from item&quot;);
		v2.ToList().ForEach(x =&amp;gt; Console.WriteLine(&quot;value : {0}&quot;, x));

		Console.ReadLine();
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When the code is bigger you have to analyse the usage of the method to understand the context.&lt;/p&gt;

&lt;p&gt;In the previous sample, the function does not return the same value depending of the context.&lt;/p&gt;

&lt;p&gt;Here is a version with the XmlProvider of &lt;a href=&quot;http://fsharp.github.io/FSharp.Data/&quot;&gt;Fsharp.Data&lt;/a&gt; :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#r @&quot;..\packages\FSharp.Data\lib\net40\FSharp.Data.dll&quot;
open FSharp.Data

let [&amp;lt;Literal&amp;gt;] nodeSample = &quot;&quot;&quot;&amp;lt;node&amp;gt;

	&amp;lt;item&amp;gt;
		&amp;lt;value&amp;gt;10&amp;lt;/value&amp;gt;
	&amp;lt;/item&amp;gt;
	&amp;lt;value&amp;gt;100&amp;lt;/value&amp;gt;

&amp;lt;/node&amp;gt;&quot;&quot;&quot;

type Node = XmlProvider&amp;lt; nodeSample &amp;gt;

let node = Node.Parse(nodeSample)

printfn &quot;from root&quot;
printfn &quot;%i&quot; (node.Value)
printfn &quot;from item&quot;
printfn &quot;%i&quot; (node.Item.Value)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;In this version, there is no need to build a function to extract and parse the value.
There is no ambigous context between the item and root value&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-friend-of-estimation&quot;&gt;The friend of estimation&lt;/h2&gt;

&lt;p&gt;In our team, we analyse complexity to dispatch work by using t-shirt size scale.
I use fsharp to build a simple fsx with our domain, the data sample of the partner in order to understand their domain (It is not only protocol but domain and business adaptation over the time intervals)
FSharp.Data speed up the process because the porcelain and plumbing part (xml, json, … all service layer) is done by FSharp.Data and we have a better complexity feedback.
The reason it that sometimes, the partner protocol is really verbose and it is harder to navigate into a json or xml than an instanciated object in the interactive mode).&lt;/p&gt;

&lt;p&gt;Before using fsharp.data, I was a System.Xml.Linq ninja :) for estimation purpose, but for now, each time there was a verbose/complex data to understand, I first use a fsharp script.&lt;/p&gt;

&lt;h2 id=&quot;flexibility&quot;&gt;Flexibility&lt;/h2&gt;

&lt;p&gt;When the partner change their protocol, we have to change the adapter with the new sample and it is really hard to make a diff between 2 sample where data is completely different.
So, we add a test like but due to the context problem, it is really hard to see if the change have same name but not the same structure and scope.&lt;/p&gt;

&lt;p&gt;Like Xml Linq, FSharp.Data is tolerent :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;What about changes that we don’t need :&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#r @&quot;..\packages\FSharp.Data\lib\net40\FSharp.Data.dll&quot;
open FSharp.Data

type Node = XmlProvider&amp;lt; &quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;id&amp;gt;50&amp;lt;/id&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot; &amp;gt;

let node = Node.Parse(&quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that the parse content does not have an id element&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The interactive display :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Code : ABC
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Breaking changes at runtime (when the partner break things directly in prod : data differ from the spec at runtime)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#r @&quot;..\packages\FSharp.Data\lib\net40\FSharp.Data.dll&quot;
open FSharp.Data

type Node = XmlProvider&amp;lt; &quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;id&amp;gt;50&amp;lt;/id&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot; &amp;gt;

let node = Node.Parse(&quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot;)

printfn &quot;Id : %i&quot; (node.Id)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The code compiles but there was a problem at runtime :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;System.Exception: XML mismatch: Expected exactly one 'id' child, got 0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Breaking changes on legacy code (when a make a quick fix) :&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#r @&quot;..\packages\FSharp.Data\lib\net40\FSharp.Data.dll&quot;
open FSharp.Data

type Node = XmlProvider&amp;lt; &quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot; &amp;gt;

let node = Node.Parse(&quot;&quot;&quot;&amp;lt;root&amp;gt;&amp;lt;code&amp;gt;ABC&amp;lt;/code&amp;gt;&amp;lt;/root&amp;gt;&quot;&quot;&quot;)

printfn &quot;Id : %i&quot; (node.Id)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Note that the required Id (used by the printfn) has been removed from the given sample&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There is an error at design time that we have to fix without adding a new unit test.&lt;/p&gt;

&lt;h2 id=&quot;performance&quot;&gt;Performance&lt;/h2&gt;

&lt;p&gt;FSharp.Data use an erased type provider, so the cost of this abstraction is paid at design time.&lt;/p&gt;

&lt;p&gt;When the application is built, all supplied types (like the type Node in our sample) are discarded.&lt;/p&gt;

&lt;p&gt;So all the abstraction is inline by a System.Xml.Linq call. The performance is equivalent to the System.Xml.Linq version.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;We have first use a fsharp module to existing csharp apps in order to infer the partner domain&lt;/li&gt;
  &lt;li&gt;The performance are equivalent to a hand made Xml Linq version&lt;/li&gt;
  &lt;li&gt;The estimation part is quicker because it require less xml linq plumbing&lt;/li&gt;
  &lt;li&gt;Quick fix is possible due to the move from unit test feedback to design time and compiler feedback&lt;/li&gt;
  &lt;li&gt;There was more test around the domain of our partner and not only on the serialization/deserialization part&lt;/li&gt;
  &lt;li&gt;I have replaced my linqpad + fiddler by fsharp script&lt;/li&gt;
  &lt;li&gt;When the breaking changes are too high, we completelty rewrite the adapter by using fsharp and see that the LOC has half&lt;/li&gt;
  &lt;li&gt;The proof of concept code could be reused (better than extract linqpad code and import to existing + code after unit test)&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">Actually, I work for a company that deal with hundreds of connectivities.</summary></entry><entry><title type="html">How to parse a proto3 message with FParsec</title><link href="https://cboudereau.github.io//fsharp/parser/combinator/fparsec/proto3/2017/08/10/proto3-parser.html" rel="alternate" type="text/html" title="How to parse a proto3 message with FParsec" /><published>2017-08-10T13:13:00+02:00</published><updated>2017-08-10T13:13:00+02:00</updated><id>https://cboudereau.github.io//fsharp/parser/combinator/fparsec/proto3/2017/08/10/proto3-parser</id><content type="html" xml:base="https://cboudereau.github.io//fsharp/parser/combinator/fparsec/proto3/2017/08/10/proto3-parser.html">&lt;p&gt;I would like to try &lt;a href=&quot;http://www.quanttec.com/fparsec/&quot;&gt;FParsec&lt;/a&gt; fsharp parser to parse proto3 message.&lt;/p&gt;

&lt;p&gt;I used this &lt;a href=&quot;http://www.quanttec.com/fparsec/&quot;&gt;FParsec&lt;/a&gt; &lt;a href=&quot;http://www.quanttec.com/fparsec/tutorial.html#parsing-json&quot;&gt;tutorial&lt;/a&gt; first in order to be more familiar with this library.&lt;/p&gt;

&lt;h2 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;This is not a production code
proto3 specification is &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3&quot;&gt;here&lt;/a&gt; if you want to continue with this script.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-proto3-message-sample&quot;&gt;The proto3 message sample&lt;/h2&gt;
&lt;p&gt;proto3 is a message format used by &lt;a href=&quot;https://github.com/mgravell/protobuf-net&quot;&gt;protobuf-net&lt;/a&gt; for example and could be export from type having some attributes indicating the mapping Id &amp;lt;-&amp;gt; properties and other metadata for the serialization configuration.&lt;/p&gt;

&lt;p&gt;For more information about proto spec, read this &lt;a href=&quot;https://developers.google.com/protocol-buffers/docs/proto3&quot;&gt;documentation&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;To start, I will use this first sample and make step by step all parsers to get the type info in this structure :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Type = 
    | Scalar of string
    | Custom of string

type FieldSpec = 
    { Id : int
      Type: Type
      Name : string }

type Field = 
    | Required of FieldSpec
    | Optional of FieldSpec
    | Repeated of FieldSpec

type Message = 
    { Name : string
      Fields : Field list } 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Here is the sample that we will use all along this post :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    message CalculateInfo {
    required string CalStarttime=1;
    optional string CalEndtime=2;
    required string Smiles=3;
    optional string CAS=4;
    optional string ChName=5;
    optional string EnName=6;
    required string Param=7;
    required bytes Result=8;
    required bool IsFinished=9;
    required bool IsFinished=9; }

    message GetAllCalulateResponse{
        required bool  isSuccessful = 1;
        required int32 Count=2;
        repeated CalculateInfo History=3; }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;lets-go-&quot;&gt;Lets go !&lt;/h2&gt;
&lt;p&gt;The FParsec references (I will write with REPL style, so I will use a .fsx).&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#I __SOURCE_DIRECTORY__
#r &quot;packages/FParsec/lib/net40-client/FParsecCS.dll&quot;
#r &quot;packages/FParsec/lib/net40-client/FParsec.dll&quot;
#r &quot;System.Core.dll&quot;
#r &quot;System.dll&quot;
#r &quot;System.Drawing.dll&quot;
#r &quot;System.Numerics.dll&quot;

open FParsec
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;step-1--extracting-the-name-of-the-message&quot;&gt;Step 1 : extracting the name of the message&lt;/h2&gt;
&lt;p&gt;In our case we want to extract the first message name : CalculateInfo&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let msgSample = &quot;message CalculateInfo {&quot;

let pMessage = spaces &amp;gt;&amp;gt;. pstringCI &quot;message&quot; &amp;gt;&amp;gt;. spaces &amp;gt;&amp;gt;. (noneOf &quot;{ &quot; |&amp;gt; manyChars) 

run pMessage msgSample
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The pMessage function will :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;skip any spaces (including line break),&lt;/li&gt;
  &lt;li&gt;parse the world (case insensitive) “message”,&lt;/li&gt;
  &lt;li&gt;skip any spaces&lt;/li&gt;
  &lt;li&gt;extract any chars (manyChars will convert chars to string) except (noneOf take a string and extract each char as blacklist) “ “ (whitespace) and “{“.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The interactive will print this result :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val it : ParserResult&amp;lt;string,unit&amp;gt; = Success: &quot;CalculateInfo&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;step-2--parse-1-field&quot;&gt;Step 2 : Parse 1 field&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let fieldSample = &quot;required string CalStarttime=1&quot;

let fieldSpec f t n i = f { FieldSpec.Id=i; Type=t; Name=n }
let pRequired = stringCIReturn &quot;required&quot; (fieldSpec Required)

run pRequired fieldSample
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The pRequired will parse the word (case insensitive) required and return the fieldSpec with the parameter Required.
Let see the fieldSpec func : f parameter could be one of the choice defined into the type :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Field = 
    | Required of FieldSpec
    | Optional of FieldSpec
    | Repeated of FieldSpec
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When we look at the proto3 field definition we will parse in order :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;required string CalStarttime=1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;1/ Field rule
2/ Type
3/ Name 
4/ Id&lt;/p&gt;

&lt;p&gt;Look at the fieldSpec fun (defined in the previous code part) is exactly the adapter function that parsing after parsing will be applied to become in the end a Field instance.&lt;/p&gt;

&lt;p&gt;Let just adapt the parser in order to parse the field rules optional or repeated :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let ws = pchar ' ' |&amp;gt; manyChars |&amp;gt;&amp;gt; ignore

let fieldSample = &quot;required string CalStarttime=1&quot;

let fieldSpec f t n i = f { FieldSpec.Id=i; Type=t; Name=n }
let pRequired = stringCIReturn &quot;required&quot; (fieldSpec Required)
let pOptional = stringCIReturn &quot;optional&quot; (fieldSpec Optional)
let pRepeated = stringCIReturn &quot;repeated&quot; (fieldSpec Repeated)
let pField = ws &amp;gt;&amp;gt;. (pRequired &amp;lt;|&amp;gt; pOptional &amp;lt;|&amp;gt; pRepeated)

run pField &quot;required string CalStarttime=1&quot; //Success: &amp;lt;fun:pRequired@40-8&amp;gt;
run pField &quot;repeated string CalStarttime=1&quot; //Success: &amp;lt;fun:pRepeated@42-6&amp;gt;
run pField &quot;optional string CalStarttime=1&quot; //Success: &amp;lt;fun:pOptional@41-6&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We can see that the orElse operator &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;|&amp;gt;&lt;/code&gt; return the parser corresponding to the field rule (optional, required, repeated).&lt;/p&gt;

&lt;p&gt;Now we have a function that take only the type, name and id.&lt;/p&gt;

&lt;p&gt;Let’s go to parse the type!&lt;/p&gt;

&lt;p&gt;In proto, types are separated as scalar type and other types.&lt;/p&gt;

&lt;p&gt;We will first parse the scalar type.
The code is a little bit boring, the most interesting part is the parser function :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;module ScalarType = 
    let private mapping = 
        [ &quot;double&quot;,  typeof&amp;lt;double&amp;gt;
          &quot;float&quot;,   typeof&amp;lt;float&amp;gt;
          &quot;int32&quot;,   typeof&amp;lt;int&amp;gt;
          &quot;int64&quot;,   typeof&amp;lt;int64&amp;gt;
          &quot;uint32&quot;,  typeof&amp;lt;uint32&amp;gt;
          &quot;uint64&quot;,  typeof&amp;lt;uint64&amp;gt;
          &quot;sint32&quot;,  typeof&amp;lt;int32&amp;gt;
          &quot;sint64&quot;,  typeof&amp;lt;int64&amp;gt;
          &quot;fixed32&quot;, typeof&amp;lt;uint32&amp;gt;
          &quot;fixed64&quot;, typeof&amp;lt;uint64&amp;gt;
          &quot;sfixed32&quot;,typeof&amp;lt;int32&amp;gt;
          &quot;sfixed64&quot;,typeof&amp;lt;int64&amp;gt;
          &quot;bool&quot;,    typeof&amp;lt;bool&amp;gt;
          &quot;string&quot;,  typeof&amp;lt;string&amp;gt;
          &quot;bytes&quot;,   typeof&amp;lt;byte[]&amp;gt; ]
        |&amp;gt; Map.ofList

    let parser = 
        mapping
        |&amp;gt; Map.toSeq
        |&amp;gt; Seq.map (fst &amp;gt;&amp;gt; pstring)
        |&amp;gt; Seq.fold (&amp;lt;|&amp;gt;) pzero
		
run ScalarType.parser &quot;double&quot; //ParserResult&amp;lt;string,unit&amp;gt; = Success: &quot;double&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The parser function aim :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;take all scalar type as string into a seq.&lt;/li&gt;
  &lt;li&gt;for each string, use a string parser&lt;/li&gt;
  &lt;li&gt;use the orElse combinator and start with the pzero.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The pzero is really intesting because it will always return Error with empty error message. 
Combined with the orElse combinator it is like if you just force the second parser to be executed because the first parser will always failed.
This is exactly what we want when we would like to fold the sequence of parsers to one parser.&lt;/p&gt;

&lt;p&gt;What is displayed if there was an error ?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;run ScalarType.parser &quot;hello&quot; (*val it : ParserResult&amp;lt;string,unit&amp;gt; =
  Failure:
Error in Ln: 1 Col: 1
hello
^
Expecting: 'bool', 'bytes', 'double', 'fixed32', 'fixed64', 'float', 'int32',
'int64', 'sfixed32', 'sfixed64', 'sint32', 'sint64', 'string', 'uint32' or
'uint64'*)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Hey! not bad!&lt;/p&gt;

&lt;p&gt;If it is not a scalar type, it is a custom type :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let pWord = (&amp;lt;&amp;gt;) ' ' |&amp;gt; satisfy |&amp;gt; manyChars

let pType = 
    (ScalarType.parser |&amp;gt;&amp;gt; Scalar)
    &amp;lt;|&amp;gt; (ws &amp;gt;&amp;gt;. pWord |&amp;gt;&amp;gt; Custom)
	
run pType &quot;hello&quot; //ParserResult&amp;lt;Type,unit&amp;gt; = Success: Custom &quot;hello&quot;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;There is only the name and identifier missed to build the full field parser, so here is the full code of the field parser :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let (&amp;lt;*&amp;gt;) f x = f &amp;gt;&amp;gt;= fun f' -&amp;gt; x &amp;gt;&amp;gt;= fun x' -&amp;gt; preturn (f' x')

let pField = 
    let fieldSpec f t n i = f { Id=i; Type=t; Name=n }
    let pRequired = stringCIReturn &quot;required&quot; (fieldSpec Required)
    let pOptional = stringCIReturn &quot;optional&quot; (fieldSpec Optional)
    let pRepeated = stringCIReturn &quot;repeated&quot; (fieldSpec Repeated)
    let pField = ws &amp;gt;&amp;gt;. (pRequired &amp;lt;|&amp;gt; pOptional &amp;lt;|&amp;gt; pRepeated)
    
    let pName = ws &amp;gt;&amp;gt;. (noneOf &quot; =&quot; |&amp;gt; manyChars)
    let pId = ws &amp;gt;&amp;gt;. pstring &quot;=&quot; &amp;gt;&amp;gt;. spaces &amp;gt;&amp;gt;. pint32

    pField &amp;lt;*&amp;gt; (ws &amp;gt;&amp;gt;. pType) &amp;lt;*&amp;gt; (ws &amp;gt;&amp;gt;. pName) &amp;lt;*&amp;gt; pId

run pField &quot;required string CalStarttime=1&quot; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The result will be :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val it : ParserResult&amp;lt;Field,unit&amp;gt; =
  Success: Required {Id = 1;
          Type = Scalar &quot;string&quot;;
          Name = &quot;CalStarttime&quot;;}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Now we have to build a fields parser that parse multiple field !&lt;/p&gt;

&lt;h2 id=&quot;step-3--parsing-n-fields&quot;&gt;Step 3 : Parsing n Fields&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let pFields = spaces &amp;gt;&amp;gt;. sepEndBy pField (spaces &amp;gt;&amp;gt;. pchar ';' .&amp;gt;&amp;gt; spaces)

run pFields &quot;&quot;&quot;required string CalStarttime=1;optional string CalEndtime=2&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;with more samples :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;run pFields &quot;&quot;&quot;required string CalStarttime=1; optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;required string CalStarttime=1 ; optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;
required string CalStarttime=1 ; optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;
 required string CalStarttime=1 ; optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;
    required string CalStarttime=1 ; optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;
    required string CalStarttime=1;
    optional string CalEndtime=2;&quot;&quot;&quot;
run pFields &quot;&quot;&quot;
    required string CalStarttime=1;
    optional string CalEndtime=2;
    
    &quot;&quot;&quot;
run pFields &quot;&quot;&quot;


    required string CalStarttime=1;
    optional string CalEndtime=2;
    
    &quot;&quot;&quot;
run pFields &quot;&quot;&quot;


    required string CalStarttime=1;

    optional string CalEndtime=2;
    
    &quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;step-final--the-full-parser&quot;&gt;Step final : the full parser&lt;/h2&gt;
&lt;p&gt;And now we have to combine pFields + pMessge together!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let message name fields = { Fields=fields; Name=name }

let pProtoMessage = pMessage |&amp;gt;&amp;gt; message .&amp;gt;&amp;gt; spaces .&amp;gt;&amp;gt; pchar '{' .&amp;gt;&amp;gt; spaces &amp;lt;*&amp;gt; pFields .&amp;gt;&amp;gt; spaces .&amp;gt;&amp;gt; pchar '}'

let pProtos = sepEndBy pProtoMessage spaces

run pProtos &quot;&quot;&quot;
    message CalculateInfo {
    required string CalStarttime=1;
    optional string CalEndtime=2;
    required string Smiles=3;
    optional string CAS=4;
    optional string ChName=5;
    optional string EnName=6;
    required string Param=7;
    required bytes Result=8;
    required bool IsFinished=9;
    required bool IsFinished=9; }

    message GetAllCalulateResponse{
        required bool  isSuccessful = 1;
        required int32 Count=2;
        repeated CalculateInfo History=3; }
&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And the final result of our parser!&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;val it : ParserResult&amp;lt;Field list,unit&amp;gt; =
  Success: [Required {Id = 1;
           Type = Scalar &quot;string&quot;;
           Name = &quot;CalStarttime&quot;;}; Optional {Id = 2;
                                              Type = Scalar &quot;string&quot;;
                                              Name = &quot;CalEndtime&quot;;}]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Finally, we see step by step how to deal with FParsec to build and compose parser together by building a full proto message parser.
This parser could be composed with an enum parser. The enum parser could reuse the internal message parser, and so on…&lt;/p&gt;</content><author><name></name></author><summary type="html">I would like to try FParsec fsharp parser to parse proto3 message.</summary></entry><entry><title type="html">Parser Combinator in real life</title><link href="https://cboudereau.github.io//fsharp,/parser/combinator/2017/08/09/why-parser.html" rel="alternate" type="text/html" title="Parser Combinator in real life" /><published>2017-08-09T13:14:01+02:00</published><updated>2017-08-09T13:14:01+02:00</updated><id>https://cboudereau.github.io//fsharp,/parser/combinator/2017/08/09/why-parser</id><content type="html" xml:base="https://cboudereau.github.io//fsharp,/parser/combinator/2017/08/09/why-parser.html">&lt;p&gt;I had to write an application that handle 2200 msg per second. 
This application consist of indexing and compress data with 7z.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I will write another post for the usage of the awesome &lt;a href=&quot;https://github.com/zeromq/fszmq&quot;&gt;fszmq&lt;/a&gt; and a custom interop of 7z in a later post.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;disclaimer&quot;&gt;Disclaimer&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;I attempted to use Linq to xml that load entirely the document element by element in memory causing LOH (on data that I don’t want to index) problem when a big element is loaded.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The XmlProvider is based on Linq so I had the same problem.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Both are very usefull and the usage of parser combinator is overkill when there is no reason :)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;the-problem&quot;&gt;The Problem&lt;/h2&gt;
&lt;p&gt;All my documents consist of a xml document that contains information to store and organize for indexation process and other data to just forward (to the 7z zipper part).&lt;/p&gt;

&lt;p&gt;2 elements of the xml contain logs of partners request/response data. 
Those 2 elements could have more than 10MB and I don’t want to load this kind of message entirely due to LOH + GC problems (avg is near 1200msg/s :)).&lt;/p&gt;

&lt;p&gt;When I check the linq to xml implementation, it load the document entirely element by element in memory with the XmlReader.&lt;/p&gt;

&lt;p&gt;So, I first wrote a simple code that use the XmlReader but :&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I don’t know when this XmlReader read or not the data.&lt;/li&gt;
  &lt;li&gt;It is hard to have a clean context&lt;/li&gt;
  &lt;li&gt;But it works!&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After 2 weeks in production, I discover a new corner case like this :&lt;/p&gt;

&lt;p&gt;An Id could be represent as&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;root&amp;gt;
&amp;lt;Id&amp;gt;1&amp;lt;/Id&amp;gt;
&amp;lt;Request&amp;gt;Big Data here !&amp;lt;/Request&amp;gt;
&amp;lt;Response&amp;gt;Big Data here !&amp;lt;/Response&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;root&amp;gt;
&amp;lt;Id&amp;gt;0&amp;lt;/Id&amp;gt;
&amp;lt;items&amp;gt;&amp;lt;item&amp;gt;&amp;lt;Id&amp;gt;1&amp;lt;/Id&amp;gt;&amp;lt;Request&amp;gt;Big Data here !&amp;lt;/Request&amp;gt;&amp;lt;Response&amp;gt;Big Data here !&amp;lt;/Response&amp;gt;&amp;lt;/item&amp;gt;&amp;lt;/items&amp;gt;
&amp;lt;/root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I remember how Linq and FSharp.Data were very usefull in this case but for the performance reason it is not ok!&lt;/p&gt;

&lt;p&gt;After dealing with if/else/pattern matching approach, I tried Parser Combinator style.
Instead parsing char, the context used by the parser is the XmlReader.
I don’t want to rewrite a full xml parser because parsing xml is too hard and XmlReader is ok for that point.&lt;/p&gt;

&lt;h2 id=&quot;a-solution-in-functional-style&quot;&gt;A Solution in Functional style&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;I have to index a lots of document so compose a parser should be easy
The solution should offer a maximum of flexibility to compose things together&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I would like to express code like this :&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Entry = { Id:string } 
let convert message = 
	use reader = XmlReader.Create(message:Stream)
	let entry id = { Id=id }
	let entryP = ffwd &quot;Id&quot; &amp;gt;&amp;gt;. element (id &amp;gt;&amp;gt; Ok) &quot;Id&quot;
	run reader entryP
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The Parser type that wrap the parser function.
The aim of parser function is like an interface but instead it hide the context and error types&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Parser&amp;lt;'x, 'a&amp;gt; = Parser of ('x -&amp;gt; Result&amp;lt;'a, string list&amp;gt;) 
let run context (Parser p) = p context
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Where ‘x could be the XmlReader and the run function that just unwrap the parser function and apply the given context.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;.&lt;/code&gt; is an operator that takes 2 parser and return the result of the right parser. 
If you understand the meaning of the point you should intuitively understand that the &lt;code class=&quot;highlighter-rouge&quot;&gt;.&amp;gt;&amp;gt;&lt;/code&gt; do the same except that it return the left result
&lt;code class=&quot;highlighter-rouge&quot;&gt;.&amp;gt;&amp;gt;.&lt;/code&gt; return both left and right result.&lt;/p&gt;

&lt;p&gt;Quite Simple !&lt;/p&gt;

&lt;p&gt;the full parser code based on XmlReader&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;type Parser&amp;lt;'x, 'a&amp;gt; = Parser of ('x -&amp;gt; Result&amp;lt;'a, string list&amp;gt;) 

//The code is based on the latest fsharp 4.1 (install vs2017 + fsharp 4.1 for eg)
open Result

let run context (Parser p) = p context
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Define a map function that&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Execute the parser x&lt;/li&gt;
  &lt;li&gt;If is ok, the parser x return a x’ result. Just apply x’ to f and return Ok&lt;/li&gt;
  &lt;li&gt;Stop if there is an error and do not apply f (show the error string list for exemple)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let map f x = 
    fun reader -&amp;gt;
        match run reader x with
        | Ok x' -&amp;gt; f x' |&amp;gt; Ok
        | Error e -&amp;gt; Error e
    |&amp;gt; Parser

let (&amp;lt;!&amp;gt;) = map
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Define an apply function that do&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Execute the run on the reader context on f and x&lt;/li&gt;
  &lt;li&gt;if parsers f and x in sequence return both ok then return Ok f’ x’&lt;/li&gt;
  &lt;li&gt;Like map stop on error&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let apply f x = 
    fun reader -&amp;gt;
        match run reader f, run reader x with
        | Ok f', Ok x' -&amp;gt; Ok (f' x')
        | Error e, _ | _, Error e -&amp;gt; Error e
    |&amp;gt; Parser

let (&amp;lt;*&amp;gt;) = apply
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The famous so called “combinator” function that&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Parse x and y in sequence and return one or both depending on the “.” on operator&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/// return y result if x and y are Ok in sequence
let (&amp;gt;&amp;gt;.) x y = 
    fun reader -&amp;gt;
        match run reader x with
        | Ok _ -&amp;gt; run reader y
        | Error e -&amp;gt; Error e
    |&amp;gt; Parser

/// return x result if x and y are Ok in sequence
let (.&amp;gt;&amp;gt;) x y = 
    fun reader -&amp;gt;
        match run reader x with
        | Ok x' -&amp;gt; 
            match run reader y with
            | Ok _ -&amp;gt; Ok x'
            | Error e -&amp;gt; Error e
        | Error e -&amp;gt; Error e
    |&amp;gt; Parser

/// return (x, y) as struct results if x and y are Ok in sequence
let (.&amp;gt;&amp;gt;.) x y = 
    fun reader -&amp;gt;
        match run reader x with
        | Ok x' -&amp;gt; 
            match run reader y with
            | Ok y' -&amp;gt; Ok (struct(x', y'))
            | Error e -&amp;gt; Error e
        | Error e -&amp;gt; Error e
    |&amp;gt; Parser
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The aim of many function is like an unfold on List, 
so while there is no error aggregate result to a list and return the list on the first error&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let many x = 
    fun reader -&amp;gt;
        List.unfold 
            &amp;lt;| fun reader -&amp;gt; match run reader x with Ok x' -&amp;gt; Some (x', reader) | Error _ -&amp;gt; None
            &amp;lt;| reader
        |&amp;gt; Ok

   |&amp;gt; Parser
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The orElse combinator is like a branch condition, if x has an error then run y.
But if x is ok, just return x without running y&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let orElse x y = 
    fun reader -&amp;gt;
        match run reader x with
        | Ok x' -&amp;gt; Ok x'
        | Error e1 -&amp;gt; 
            match run reader y with
            | Ok y' -&amp;gt; Ok y'
            | Error e2 -&amp;gt; Error (List.append e1 e2)
    |&amp;gt; Parser

let (&amp;lt;|&amp;gt;) = orElse
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ok now I have the abstraction to parse any context.&lt;/p&gt;

&lt;p&gt;Remember that my context is the XmlReader&lt;/p&gt;

&lt;p&gt;The Xml helper function&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open System.Xml
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Hey it is xml :)&lt;/p&gt;

&lt;p&gt;I Have to deal with XmlReader that confuse technical error with business error with the same way…
So lets go to catch!&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let tryF name f (reader:XmlReader) = 
    try
        f reader
    with ex -&amp;gt; Error [sprintf &quot;expected %s got an error:\r\n%O&quot; name ex]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The ffwd just fast forward the XmlReader to the given name&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let ffwd name = 
    fun (reader:XmlReader) -&amp;gt; 
        while reader.Name &amp;lt;&amp;gt; name &amp;amp;&amp;amp; not reader.EOF &amp;amp;&amp;amp; reader.Read() do ()
        |&amp;gt; Ok
    |&amp;gt; Parser
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The element function read the element with the given name, and apply the function f to the content&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let element f name = 
    tryF name &amp;lt;| fun reader -&amp;gt;
        reader.ReadStartElement(name)
        if reader.NodeType = XmlNodeType.Text then
            let result = f (reader.ReadContentAsString())
            reader.ReadEndElement()
            result 
        else 
            let result = f &quot;&quot;
            if reader.NodeType = XmlNodeType.EndElement then reader.ReadEndElement()
            result
    |&amp;gt; Parser
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The nested function treat the nested element case like :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;item&amp;gt;...&amp;lt;/item&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let nested name p = 
    tryF name &amp;lt;| fun reader -&amp;gt;
        reader.ReadStartElement(name)
        let result = run reader p
        reader.ReadEndElement()
        result
    |&amp;gt; Parser
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The pIgnore skip an element and return unit (very usefull with .» pIgnore or pIgnore ».)&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;let pIgnore = 
    fun (reader:XmlReader) -&amp;gt; 
        reader.ReadStartElement()
        reader.Skip()
        reader.ReadEndElement()
        Ok ()
    |&amp;gt; Parser 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;some-examples&quot;&gt;Some Examples&lt;/h2&gt;
&lt;p&gt;A sample parser implementation :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open System 
open System.IO

type Entry = 
    { Keys: string Set
      Date : DateTime 
      Data: Stream }

let convert (message:Stream) = 
    let reader = XmlReader.Create(new StreamReader(message))
    let elt f x = element (f &amp;gt;&amp;gt; Ok) x
    let strE x = elt id x
    let ffwdE x f = ffwd x &amp;gt;&amp;gt;. element (f &amp;gt;&amp;gt; Ok) x
    let pIsSuccess = ffwdE &quot;MessageType&quot; ((&amp;lt;&amp;gt;) &quot;Failed&quot;)

    let pHid = ffwdE &quot;HotelId&quot; int
    let pGid = elt int &quot;GroupId&quot;
    
    let parseDate s = 
        System.DateTime.Parse(s, Globalization.CultureInfo.InvariantCulture, Globalization.DateTimeStyles.AssumeUniversal).ToUniversalTime()

    let pDate = elt parseDate &quot;Date&quot;
    
    let pStartDate = ffwdE &quot;Start&quot; parseDate
    let pEndDate = elt parseDate &quot;End&quot;

    let pRoomCode = strE &quot;RoomCode&quot;
    let pRoomId = elt int &quot;RoomId&quot;
    
    let pRooms = 
        let zero = 
            fun _ -&amp;gt; Ok Set.empty
            |&amp;gt; Parser

        let nestedO name p = nested name p &amp;lt;|&amp;gt; zero  
        let pItem = pRoomCode .&amp;gt;&amp;gt;. pRoomId
        let pItems = set &amp;lt;!&amp;gt; (many (nested &quot;item&quot; pItem))
        ffwd &quot;Rooms&quot; &amp;gt;&amp;gt;. nestedO &quot;Rooms&quot; pItems
    
    let pRoom = Set.singleton &amp;lt;!&amp;gt; (ffwd &quot;RoomCode&quot; &amp;gt;&amp;gt;. pRoomCode .&amp;gt;&amp;gt;. pRoomId)

    let roomIdsP = 
        let defaultTo x y = 
            match y with _ when y |&amp;gt; Set.isEmpty -&amp;gt; x | _ -&amp;gt; y 

        defaultTo &amp;lt;!&amp;gt; pRoom &amp;lt;*&amp;gt; pRooms

    let logEntry (message:Stream) isSuccess hotelId groupId stamp startDate endDate rooms = 
        let ssnd (struct (_,x)) = x
        let roomIds = rooms |&amp;gt; Set.map ssnd
        let key = sprintf &quot;%i/%i/%i&quot;
        let keys = roomIds |&amp;gt; Set.map(key groupId hotelId)
        { Keys = keys
          Date = stamp
          Data = 
            message.Position &amp;lt;- 0L
            message }
    
    let rawXml (message:Stream) = 
        message.Position &amp;lt;- 0L
        let sr = new StreamReader(message)
        sr.ReadToEnd()

    try
        match run reader (logEntry message &amp;lt;!&amp;gt; pIsSuccess &amp;lt;*&amp;gt; pHid &amp;lt;*&amp;gt; pGid &amp;lt;*&amp;gt; pDate &amp;lt;*&amp;gt; pStartDate &amp;lt;*&amp;gt; pEndDate &amp;lt;*&amp;gt; roomIdsP) with
        | Ok logEntry -&amp;gt; Some logEntry
        | Error errors -&amp;gt; 
            let error = System.String.Join(System.Environment.NewLine, errors |&amp;gt; Array.ofList)
            printfn &quot;[WARN]%s\r\nXml :\r\n%s&quot; error (rawXml message)
            None
    with ex -&amp;gt; failwithf &quot;Parsing failed with error %O\r\nXml:\r\n%s&quot; ex (rawXml message)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;I love this kind of little and composable declaration.
Parsing is now like a Lego game!&lt;/p&gt;

&lt;p&gt;The associated tests :&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;///Porcelain and plumbing
let convertFromString x = 
    use s = new MemoryStream()
    use sw = new StreamWriter(s)
    sw.Write(x:string)
    sw.Flush()
    s.Position &amp;lt;- 0L
    convert s

convertFromString &quot;&quot;&quot;
&amp;lt;Transport&amp;gt;&amp;lt;DestinationUri&amp;gt;dest&amp;lt;/DestinationUri&amp;gt;&amp;lt;SourceUri&amp;gt;source&amp;lt;/SourceUri&amp;gt;&amp;lt;ReplyUri /&amp;gt;&amp;lt;MessageType&amp;gt;Update&amp;lt;/MessageType&amp;gt;&amp;lt;Message&amp;gt;&amp;lt;HotelId&amp;gt;3116&amp;lt;/HotelId&amp;gt;&amp;lt;GroupId&amp;gt;9358&amp;lt;/GroupId&amp;gt;&amp;lt;Date&amp;gt;2017-02-20T16:19:12.4037606Z&amp;lt;/Date&amp;gt;&amp;lt;Request&amp;gt;Big Request&amp;lt;/Request&amp;gt;&amp;lt;Response&amp;gt;Big Response&amp;lt;/Response&amp;gt;&amp;lt;Start&amp;gt;2017-03-02&amp;lt;/Start&amp;gt;&amp;lt;End&amp;gt;2017-03-03&amp;lt;/End&amp;gt;
    &amp;lt;RoomCode&amp;gt;26757&amp;lt;/RoomCode&amp;gt;
    &amp;lt;RoomId&amp;gt;7066&amp;lt;/RoomId&amp;gt;
    &amp;lt;Rooms /&amp;gt;&amp;lt;/Message&amp;gt;&amp;lt;/Transport&amp;gt;
&quot;&quot;&quot;

/// Do not consider the first Single RoomId if equal 0 and if there is no RoomIds
convertFromString &quot;&quot;&quot;
&amp;lt;Transport&amp;gt;&amp;lt;DestinationUri&amp;gt;dest&amp;lt;/DestinationUri&amp;gt;&amp;lt;SourceUri&amp;gt;source&amp;lt;/SourceUri&amp;gt;&amp;lt;ReplyUri /&amp;gt;&amp;lt;MessageType&amp;gt;Update&amp;lt;/MessageType&amp;gt;&amp;lt;Message&amp;gt;&amp;lt;HotelId&amp;gt;3116&amp;lt;/HotelId&amp;gt;&amp;lt;GroupId&amp;gt;9358&amp;lt;/GroupId&amp;gt;&amp;lt;Date&amp;gt;2017-02-20T16:19:12.4037606Z&amp;lt;/Date&amp;gt;&amp;lt;Request&amp;gt;Big Request&amp;lt;/Request&amp;gt;&amp;lt;Response&amp;gt;Big Response&amp;lt;/Response&amp;gt;&amp;lt;Start&amp;gt;2017-03-02&amp;lt;/Start&amp;gt;&amp;lt;End&amp;gt;2017-03-03&amp;lt;/End&amp;gt;
    &amp;lt;RoomCode /&amp;gt;
    &amp;lt;RoomId&amp;gt;0&amp;lt;/RoomId&amp;gt;
    &amp;lt;Rooms&amp;gt;
        &amp;lt;item&amp;gt;
            &amp;lt;RoomCode&amp;gt;16239&amp;lt;/RoomCode&amp;gt;
            &amp;lt;RoomId&amp;gt;3347&amp;lt;/RoomId&amp;gt;
        &amp;lt;/item&amp;gt;
        &amp;lt;item&amp;gt;
            &amp;lt;RoomCode&amp;gt;16241&amp;lt;/RoomCode&amp;gt;
            &amp;lt;RoomId&amp;gt;3346&amp;lt;/RoomId&amp;gt;
        &amp;lt;/item&amp;gt;
   &amp;lt;/Rooms&amp;gt;&amp;lt;/Message&amp;gt;&amp;lt;/Transport&amp;gt;
&quot;&quot;&quot;

/// Use the RoomId 0 = All Rooms when the is empty RoomIds
convertFromString &quot;&quot;&quot;
&amp;lt;Transport&amp;gt;&amp;lt;DestinationUri&amp;gt;dest&amp;lt;/DestinationUri&amp;gt;&amp;lt;SourceUri&amp;gt;source&amp;lt;/SourceUri&amp;gt;&amp;lt;ReplyUri /&amp;gt;&amp;lt;MessageType&amp;gt;Update&amp;lt;/MessageType&amp;gt;&amp;lt;Message&amp;gt;&amp;lt;HotelId&amp;gt;3116&amp;lt;/HotelId&amp;gt;&amp;lt;GroupId&amp;gt;9358&amp;lt;/GroupId&amp;gt;&amp;lt;Date&amp;gt;2017-02-20T16:19:12.4037606Z&amp;lt;/Date&amp;gt;&amp;lt;Request&amp;gt;Big Request&amp;lt;/Request&amp;gt;&amp;lt;Response&amp;gt;Big Response&amp;lt;/Response&amp;gt;&amp;lt;Start&amp;gt;2017-03-02&amp;lt;/Start&amp;gt;&amp;lt;End&amp;gt;2017-03-03&amp;lt;/End&amp;gt;
    &amp;lt;RoomCode /&amp;gt;
    &amp;lt;RoomId&amp;gt;0&amp;lt;/RoomId&amp;gt;
    &amp;lt;/Message&amp;gt;&amp;lt;/Transport&amp;gt;
&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;the-pros&quot;&gt;The pros&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Easy to write&lt;/li&gt;
  &lt;li&gt;Easy to maintain&lt;/li&gt;
  &lt;li&gt;Hey it is composition, I can reuse parser and compose them to create new one!&lt;/li&gt;
  &lt;li&gt;It fix a real issue (I start writing a code that parse xml with XmlReader with hard issue to solve in existing code)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-cons&quot;&gt;The cons&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;It was my first attempt, so the first parser was harder to write but others were very easy to compose (The most part was to understand how works XmlReader and when the context has changed or not!)&lt;/li&gt;
  &lt;li&gt;The use of operator and applicative separate the definition of the function from its execution. When you are debugging the run function you have to deal with a stack containing operator name (like GreaterGreaterEqual). Inlining the operator could help but it is more difficult to debug.&lt;/li&gt;
  &lt;li&gt;For now, in my experience, I delivered multiple fix / multiple parsers composition and it is not a big deal to change my habits, finally it was easy to fix and maintain.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In &lt;a href=&quot;/fsharp/parser/combinator/fparsec/proto3/2017/08/10/proto3-parser.html&quot;&gt;this post&lt;/a&gt; I will introduce &lt;a href=&quot;http://www.quanttec.com/fparsec/&quot;&gt;FParsec&lt;/a&gt; in order to parse proto3 file.&lt;/p&gt;

&lt;h2 id=&quot;links&quot;&gt;Links&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://fsharpforfunandprofit.com/posts/understanding-parser-combinators/&quot;&gt;Understanding Parser Combinators/Scott Wlaschin&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.haskell.org/Monad&quot;&gt;Monad/Haskell wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">I had to write an application that handle 2200 msg per second. This application consist of indexing and compress data with 7z.</summary></entry></feed>